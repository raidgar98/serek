\documentclass[12pt]{article}

% support for images
\usepackage{graphicx}

% font
\usepackage{tgheros}
\renewcommand*\familydefault{\sfdefault}
\usepackage[T1]{fontenc}


% justify
\usepackage{ragged2e}

% indents
\usepackage{indentfirst}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt}
\setlength{\JustifyingParindent}{1.25cm}
% source: https://tex.stackexchange.com/a/121230
\renewenvironment{justify}{%
	\trivlist
	\justifying
	\itemindent\JustifyingParindent
	\item\relax
	}{%
	\endtrivlist
}
\justifying

% fonts, margins, etc...
\usepackage{setspace}
\usepackage{authoraftertitle}
\usepackage{tikz}
\usepackage{anyfontsize}
\usetikzlibrary{positioning,calc}

% language
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[english,polish]{babel}

% bibliography
\usepackage{biblatex}
\addbibresource{../bibliography.bib}

% configure code fields
\usepackage{listings}
\lstdefinestyle{customcpp}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C++,
  showstringspaces=false,
  basicstyle=\fontsize{9pt}{9}\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  stringstyle=\color{orange},
}
\lstset{
	backgroundcolor=\color{white},
	language=C++,
	style=customcpp,
	tabsize=2
}

% set margins
\usepackage[
	a4paper,
	left=2.5cm,
	right=2.5cm,
	top=2.5cm,
	bottom=2.5cm,
	bindingoffset=1cm,
	headheight=1.25cm,
	footheight=1.35cm
]{geometry}

% configure header and footer (with page numbering)
\usepackage[lastpage,user]{zref}
\usepackage[bottom]{footmisc}
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\fancyhf{}
\pagestyle{fancy}
\cfoot{\thepage\ z~\zpageref{LastPage}}

% document info
\title{Implementacja i~badanie wydajności serializacji wykonanej w~paradygmacie metaprogramowania względem standardowych rozwiązań w~języku C++}
\author{inż. Krzysztof MOCHOCKI}
\newcommand{\polishkeywords}{serializacja, deserializacja, C++, szablony, wydajność, metaprogramowanie}
\date{}

% configure enumerator
\renewcommand{\labelenumi}{\arabic{enumi}.}
\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}.}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.}
\renewcommand{\labelenumiv}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.\arabic{enumiv}.}

% configure sections
\usepackage{titlesec}
\titleformat{\section}{\normalfont\Large\bfseries}{\thesection.}{1em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{\thesubsection.}{1em}{}
\titleformat{\subsubsection}{\normalfont\normalsize\bfseries}{\thesubsubsection.}{1em}{}

% function for disabling hyphenation
\newcommand{\disablewordwrap}{%
	\setlength{\hsize}{0.9\hsize}
	% \tolerance=1
	\hyphenpenalty=10000
	\hbadness=10000}

% configuration of table of contents
\usepackage{tocloft}
\setcounter{tocdepth}{2}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

% hide hyperlinks and set pdf properties
\usepackage[pdftex, hidelinks,
	pdfauthor={\MyAuthor},
	pdftitle={\MyTitle},
	pdfsubject={Praca Magisterska},
	pdfkeywords={\polishkeywords},
	pdfproducer={Latex with hyperref},
	pdfcreator={pdflatex}
]{hyperref}

% add page break with new section
\newcommand{\sectionbreak}{\pagebreak}

% configure quotation
\usepackage{etoolbox}
\AtBeginEnvironment{quotation}{\itshape}

% source: https://tex.stackexchange.com/a/237203
\usepackage{newfloat}
\DeclareFloatingEnvironment[listname={}]{captioned}
\addto\captionspolish{%
	\renewcommand{\captionedname}{Rysunek}%
}

% configuration of figure captions
% source: https://tex.stackexchange.com/a/276796
\usepackage{caption}
\captionsetup[captioned]{labelfont={bf}, labelformat={default}, labelsep=period, name={Rysunek}}

% configure placing of figures in-text
% source: https://tex.stackexchange.com/a/8633
\usepackage{float}

% line spread
\linespread{1.5}

% aliases
\newcommand{\n}{\newline}
\newcommand{\putss}[3]{
\begin{captioned}[H]
	\centering
	\includegraphics[width=15cm,keepaspectratio=true]{#1}
	\caption{#2}
	\label{#3}
	\medskip
\end{captioned}
}
\newcommand{\putfig}[3]{
\begin{captioned}[H]
	\centering
	\includegraphics[width=15cm,height=10cm,keepaspectratio=true]{#1}
	\caption{#2}
	\label{#3}
	\medskip
\end{captioned}
}

% styles
\newcommand{\nonpl}[1]{{\it #1}}
\newcommand{\code}[1]{{\it #1}}
\newcommand{\ang}[1]{\nonpl{ang. #1}}

% inglish names
\newcommand{\JSON}{\nonpl{JSON} }
\newcommand{\HTTP}{\nonpl{HTTP} }
\newcommand{\CRTP}{\nonpl{CRTP} }
\newcommand{\Jmeter}{\nonpl{Jmeter}\texttrademark}
\newcommand{\serek}{\nonpl{serek}}

% regex for orphan removal
% sed -i -e 's/([\n ])([iwaouz])[ ]/\1\2~/g'

\begin{document}

	% make default captions disappear of list of tables and list of figures
	% to set custom, numbered mentioned in ToC
	\renewcommand*\listfigurename{}
	\renewcommand*\listoftables{}

	% tittle page
	\begin{titlepage}
		\clearpage
		\topskip0pt
		\centering

		\includegraphics[width=5cm, keepaspectratio=true]{./img/black_and_white_polsl_logo.png}

		{\LARGE\bfseries\ Praca Magisterska}

		\vspace*{1cm}

		{\LARGE \MyTitle}

		\Large\bfseries\

		\begin{spacing}{1.125}
			\MyAuthor\

			000000000
			\vspace*{1cm}

			Kierunek: Informatyka Przemysłowa

			Specjalność: Inteligentne Systemy Przemysłowe

			\vspace*{1cm}

			Promotor

			dr inż. Adrian SMAGÓR

			\vspace*{0.5cm}

			Katedra Informatyki Przemysłowej

			Wydział Inżynierii Materiałowej

			\vspace*{\vfill}

			Katowice 2023
		\end{spacing}

		\thispagestyle{empty}
	\end{titlepage}

	% detail page
	{
		\disablewordwrap
		\large

		\vspace*{\vfill}

		{\bfseries\ Tytuł pracy:} \MyTitle

		\vspace*{\vfill}

		{\bfseries\ Streszczenie:} Praca ma sprawdzić możliwość skonstruowania biblioteki do w~pełni automatycznej refleksji typów, a~także przetestować jej wydajność w~zestawieniu do innych powszechnie używanych bibliotek.

		\vspace*{\vfill}

		{\bfseries\ Słowa kluczowe:} \polishkeywords

		\vspace*{\vfill}

		{\bfseries\ Thesis title:} Implementation and performance testing of serialization performed in the metaprogramming paradigm against standard solutions in the C++ language

		\vspace*{\vfill}

		{\bfseries\ Abstract:} Purpose of this paper is to check the possibility of constructing a~library for fully automatic type reflection, as well as to test its performance in comparison to other commonly used libraries.

		\vspace*{\vfill}

		{\bfseries\ Keywords:} serialization, deserialization, C++, templates, performance, metaprogramming

		\vspace*{\vfill}

		\thispagestyle{empty}
		\newpage
	}

	% blank page
	{
		 \vspace*{\vfill}
		\thispagestyle{empty}
		\newpage
	}

	% table of contents
	{
		\tableofcontents
		\thispagestyle{fancy}
		\newpage
	}

	% introduction
	{
		\section{Wstęp}

		Serializacja w~językach wysokiego poziomu, takich jak JavaScript czy Python jest, w~przypadku standardowych formatów
		reprezentacji danych, echem przeszłości, ponieważ języki te posiadają natywne wsparcie do reprezentacji struktur danych
		zapewnione przez ichniejsze biblioteki standardowe.\n

		W~momencie powstawania bieżącej pracy programiści języka C++ wciąż muszą uwzględniać problematykę
		serializacji podczas projektowania aplikacji oraz doboru bibliotek. Standard języka C++ w~roku 2023 posiada szeroką
		paletę narzędzi do pisania szablonów klas i~struktur, niestety nie posiada żadnych narzędzi do łatwego przeglądania
		struktur danych. Jest to oczywiście podyktowane względami wydajnościowymi oraz chęcią zachowania wstecznej
		kompatybilnością z~językiem C. Istnieją rozszerzenia (na przykład reflexpr \cite*{cpp_extension_reflexpr_iso}), które
		umożliwiają iterowanie po elementach struktur danych, czy ich serializację, jednakże nie są one wciąż wdrożone do
		standardu \cite*{cpp_extension_reflexpr_short}.\n

		\putfig{./charts/output_with_charts_as_images/json_vs_other_formats.png}{ Popularność wyszukiwanych technologii według strony Google \cite*{google_trends_json_api_vs_rest_of_the_world}}{json_vs_world}

		Niniejsza praca skupia się wyłącznie na formacie \JSON\cite*{json_iso}, ponieważ jak można zauważyć na powyższym wykresie (rysunek \ref{json_vs_world}), jest on
		najbardziej powszechnym standardem komunikacji na świecie. Ciekawą kwestią jest wyraźny spadek zainteresowaniem hasłem \JSON w~okresie od
		trzeciego kwartału $2020$ roku do początku $2022$, co może być spowodowane pandemią \nonpl{COVID-19}, której wpływ na tempo gospodarki światowej,
		jest całkiem prawdopodobnie widoczny również tutaj.\n

		Aktualnie możemy rozróżnić trzy podstawowe podejścia do wyzwania serializacji w~języku C++. Pierwsze, gdzie programista tylko wspomaga się
		zewnętrzną biblioteką, której jedynym zadaniem jest zapewnienie zgodności ze standardem formatu, jednakowo podczas serializacji
		oraz deserializacji, natomiast nie zapewnia refleksji typów złożonych, których serializację bądź deserializację musi
		dokonać samodzielnie.\n

		Kolejnym podejściem do tej kwestii jest rozwiązanie oparte na bibliotece, która również jak wspomniana powyżej zawiera funkcję
		serializacji i~deserializacji typów prostych, jednakże dodatkowo zawiera funkcję zewnętrznej refleksji typów,
		która najczęściej już na podstawie statycznych referencji do pola klasy, jest w~stanie wydedukować typy i~automatycznie
		poprowadzić proces serializacji lub deserializacji.\n

		Trzecim podejściem jest zastosowanie wewnętrznej refleksji. W~innych językach najczęściej jest dostarczona przez język.
		Przykładowo w~języku Python jest ona wyrażona w~postaci pola \code{\_\_dict\_\_}, które dostarcza programiście całą klasę
		w postaci dynamicznej struktury danych typu klucz-wartość: słownika, gdzie kluczem jest nazwa pola klasy o~typie
		łańcucha znakowego, natomiast wartością jest konkretna wartość w~obecnej instancji klasy. Z~punktu widzenia tematu
		niniejszej pracy, daje to pełny i~prosty wgląd w~strukturę zarówno klasy, jak i~hierarchii klas.
	}

	% theory
	{
		\section{Przegląd pojęć}

		{
			\subsection{Definicja serializacji oraz deserializacji}

			Jak podaje portal \nonpl{hazelcast.com}\cite{definitions_serial_and_deserial} definicja serializacji oraz deserializacji brzmi (tłumaczenie własne):

			\begin{quotation}
				{\bf Serializacja} to proces konwersji obiektu danych - kombinacji kodu i~danych
				reprezentowanych w~regionie przechowywania danych - w~serię bajtów zapisujących
				stan obiektu w~łatwej do przesłania formie. [\ldots] \n

				Proces odwrotny - konstruowanie struktury danych lub obiektu z~szeregu
				bajtów - to {\bf deserializacja}. Proces deserializacji odtwarza obiekt,
				dzięki temu dane są łatwiejsze do odczytania i~modyfikacji jako
				natywna struktura w~języku programowania.
			\end{quotation}
		}

		{
			\subsection{Definicja metaprogramowania}

			Opis, a~zarazem definicja, czym metaprogramowanie jest zostało opisane niniejszym cytatem \cite{metaprogramming_definition} (tłumaczenie własne):

			\begin{quotation}
				W językoznawstwie metajęzyk definiuje się w~następujący sposób [Słownik]:\n

				„dowolny język lub system symboliczny używany do omawiania, opisywania lub analizowania
				innego języka lub systemu symbolicznego”\n

				Ta definicja charakteryzuje główną ideę metaprogramowania, która obejmuje pisanie
				programów powiązanych meta-relacją, czyli relacją „bycia”. Program, który
				manipuluje innym programem jest ewidentnie przykładem metaprogramowania. [\ldots]
			\end{quotation}

			Paradygmat meta programowania w~przypadku niniejszej pracy będzie można zaobserwować przy
			rozwiązaniach z~zastosowaniem szablonów, a~także nowinki językowej w~języku C++: konceptów.
			Meta-relacja będzie się ujawniać, gdy kompilator (który w~tym wypadku będzie wykonawcą meta języka),
			będzie wykonywał i~generował automatycznie procedury refleksji typów, a~także procedury ich serializacji
			oraz deserializacji.\n
		}

		{
			\newpage
			\subsection{Definicja programowania refleksyjnego}

			Definicję programowania zorientowanego na refleksję podaje Jonathan M. Sobel oraz Daniel P. Friedman
			w swoim materiale \nonpl{An Introduction to Refection-Oriented Programming}\cite{reflection_definition},
			gdzie możemy przeczytać (tłumaczenie własne):

			\begin{quotation}
				[\ldots] refleksyjne systemy obliczeniowe umożliwiają przetwarzanie poprzez obserwację i~modyfikację
				właściwości własnego zachowania, zwłaszcza właściwości, które zazwyczaj obserwuje się tylko z~zewnętrznego,
				meta poziomowego punktu widzenia. [\ldots]
			\end{quotation}

			Dobrym przykładem programowania refleksyjnego, jest kompletna kontrola nad typami danych w~języku Python,
			gdzie istnieje pełna możliwość dynamicznego przeglądania, dodawania, czy usuwania pól w~klasie (lub wyłącznie w~jednym obiekcie)
			podczas działania programu. Jest to na tyle rozbudowany obszar w~tym języku, że istnieją biblioteki takie jak
			\nonpl{dataclasses}\cite{python_dataclass}, które podmieniają prostą definicję klasy z~wyłącznie statycznymi polami,
			na definicję klasy ze stworzonymi konstruktorami, reprezentacjami i~zwykłymi polami, należącymi do obiektu.

			Warto nadmienić, że język C++ domyślnie nie posiada zbyt wielu mechanizmów ułatwiających programowanie refleksyjne,
			co jest przyczółkiem problematyki całej niniejszej pracy.
		}
	}

	% browse of current solutions
	{
		\section{Przegląd dostępnych rozwiązań}

		{
			\subsection{Manualna refleksja pól}

			Jest to najbardziej trywialne podejście do wyzwania konwersji reprezentacji danych, które zakłada samodzielną implementację całego przejścia
			po polach klasy. Biblioteka służy tylko jako interfejs do serializacji, jednakże nie zapewnia automatycznej
			zamiany typów złożonych, jedynie typów prostych. Przykładem takiej biblioteki jest \nonpl{jsoncpp}\cite{jsoncpp_repo}.\n

			{
				\subsubsection{Korzyści i zagrożenia manualnej refleksji pól}

				Cechą charakterystyczną takich bibliotek jest sposób zapisu funkcji, które są odpowiedzialne za serializację lub deserializację
				danej klasy, ponieważ są to najczęściej długie wielokrotnie zagnieżdżone funkcje, przekształcające po kolei wszystkie pola klasy.
				Opis ten od razu wskazuje na najważniejszą wadę tego podejścia. W~przypadku zmiany struktury danych, na przykład poprzez usunięcie
				lub dodanie pola, wymagana jest ingerencja w~kod w~obu funkcjach, co zostało przedstawione na rysunku \ref{manual_reflection_example}).
				Pierwszy blok kodu obrazuje przykładową klasę, która zostanie poddana procesowi serializacji oraz deserializacji. Pierwsza funkcja
				\code{serialize\_my\_class} posiada przepis na wspomaganą biblioteką serializację klasy, natomiast kolejna (\code{deserialize\_my\_class})
				jej deserializację. Należy zwrócić uwagę, że usunięcie, dodanie lub edycja nazwy pola lub jego typu wymusza na programiście modyfikację
				obu funkcji.\n

				\begin{captioned}[H]
					\begin{lstlisting}[frame=single]
class MyClass
{
	bool field_0;
	int field_1;
	std::string field_2;
	std::vector<int> field_3;
};

std::string serialize_my_class(const MyClass& obj)
{
	lib::json json{};
	json["field_0"] = lib::json::to_json_bool(obj.field_0);
	json["field_1"] = lib::json::to_json_int(obj.field_1);
	json["field_2"] = lib::json::to_json_string(obj.field_2);
	json["field_3"] = lib::json::json_array();
	json["field_3"].reserve(obj.field_3.size());
	for(const int var : obj.field_3)
		json["field_3"].append(var);
	return json.to_string();
}

MyClass deserialize_my_class(const std::string& json_text)
{
	lib::json json = lib::json::parse_from_string(json_text);
	MyClass result{};
	result.field_0 = assert_is_field_exist_and_return("field_0").as_bool();
	result.field_1 = assert_is_field_exist_and_return("field_1").as_int();
	result.field_2 = assert_is_field_exist_and_return("field_2").as_string();
	const auto json_array = assert_is_field_exist_and_return("field_3").as_array();
	result.field_3.reserve(json_array.size());
	for(const auto& json_element : json_array)
		result.field_3.emplace_back(json_element.as_int());
	return result;
}
					\end{lstlisting}
					\caption{ Przykładowa implementacja funkcji serializacji i~deserializacji za pomocą biblioteki z~wyłącznie manualną refleksją pól}
					\label{manual_reflection_example}
				\end{captioned}

				Redukcja członka klasy nie jest jeszcze problemem, ponieważ kompilator od razu poinformuje programistę o~tym, że próbuje operować na polu,
				które (już) nie istnieje, jednakże w~przypadku dodania pola, programista może nieświadomie dodać pole, które nie będzie podlegało serializacji
				lub deserializacji. Kolejne wada tego rozwiązania kryje się w~mechanizmie konwersji typów, a~mianowicie jeżeli typ danego pola zostanie
				zmieniony i~przez przypadek istnieje niejawna, możliwa konwersja między starym a~nowym typem, serializacja oraz deserializacja może
				dyskretnie dokonywać błędnych operacji. Dobrym przykładem jest zmiana reprezentacji procentów z~liczby całkowitej od $0$ do $100$,
				na typ zmiennoprzecinkowy od $0.0$ do $1.0$. Jeżeli podmienimy typ w~klasie, ale nie podmienimy metody deserializacji, wszystkie wartości
				od $0\%$ do $99\%$ zostaną zaokrąglone do wartości całkowitej: $0$. Istnieją mechanizmy pozwalające na uchronienie programisty przed takim
				czarnym scenariuszem, na przykład w~postaci testów wzorcowych (\ang{pattern tests}), lub korzystanie w~inteligentny sposób z~szablonów,
				które mogłyby dedukować odpowiednią metodę obsługi pola, jednakże nie są one dostarczone od razu oraz nie wynikają z~filozofii
				korzystania z~tego typu bibliotek.\n

				Drugą stroną tego typu bibliotek jest, szczególnie dla młodych programistów, jest niski próg zrozumienia zasady działania
				biblioteki oraz jak należy ją używać. Inną zaletą jest duża wygoda w~implementacji własnych, niecodziennych sposobów serializacji,
				które w~przypadku dalszych rozwiązań nie jest takie oczywiste. Dobrym przykładem jest reprezentacja hasha\cite{hash_po_angielskiemu},
				od strony programu, najlepiej, żeby był reprezentowany binarnej, ponieważ zajmuje o~wiele mniej miejsca oraz wygodnie się go przetwarza,
				natomiast z~punktu widzenia warstwy transportowej, zdecydowanie lepszym zapisem jest forma łańcucha znaków, która jest łatwiejsza do porównania
				przez człowieka. Biblioteki z~manualną refleksją typów naturalnie poradzą sobie z~takimi wyzwaniami, ponieważ programista może bez problemu
				wywołać funkcję, która dokona odpowiedniej konwersji. Dalej omawiane rozwiązania wymagają sprytnego przeładowywania funkcji lub
				stosowania obiektów pośrednich.
			}
		}

		{
			\subsection{Pół automatyczna refleksja pól}

			Podejście to wymaga biblioteki, która posiada odpowiednie funkcje lub makra, umożliwiające dokonanie pół automatycznej
			refleksji pól struktury danych. Po skorzystaniu z~takiego zewnętrznego zasobu programista nie ma bezpośredniego dostępu do samego momentu
			wpisania lub odczytu wartości z~pól klasy. Przykładem takiej biblioteki jest \nonpl{fc}\cite{fc_repo}.\n

			{
				\subsubsection{Korzyści i zagrożenia pół automatycznej refleksji pól}

				Fakt ukrycia tego mechanizmu przez bibliotekę ujawnia pierwszą trudność przy wykorzystaniu tego podejścia: trudność w~ustawienia własnych
				metod serializacji, szczególnie jeżeli biblioteka nie przewiduje takiego interfejsu. Natomiast, jeżeli nawet istnieje taka możliwość,
				to może ono doprowadzać do skomplikowania interfejsu, co zaś może doprowadzać do podwyższenia poziomu wejścia dla nowych programistów.\n

				Jednakże to podejście nie rozwiązuje również w~pełni problemu przedstawionego w~poprzednim podrozdziale, gdzie została wspomniana
				możliwość zmiany struktury klasy, na co nie zareaguje sam mechanizm serializacji z~uwagi na istnienie
				konieczności manualnego wpisania jakie pola chcemy, żeby podlegały serializacji. Podejście z~półautomatyczną refleksją
				chroni programistę przed usunięciem pola oraz zmianą typu pola, ponieważ sposób obsługi danego pola jest dedukowany przy
				kompilacji, za każdym razem. Jednakże wciąż istnieje możliwość dodania pola, a~nie zostanie to zauważone, aż do pierwszych testów
				przez programistę. Można to próbować rozwiązać poprzez na przykład dodatkowe sprawdzanie wielkości klasy przy kompilacji.
				Opisane korzyści można zaobserwować na przykładzie przedstawionym na rysunku numer \ref{half_automatic_example}. Wspomniany
				rysunek prezentuje dwa pliki, wyróżnione za pomocą odpowiedniego komentarza. Pierwszy fragment prezentuje przykładową klasę oraz
				jej zewnętrzną manualną refleksję z~pomocą przykładowej biblioteki. Druga część (po komentarzu \code{// MyClass.cpp}) pokazuje
				całą implementację odpowiednio funkcji serializacji oraz deserializacji.\n

				\begin{captioned}[H]
					\begin{lstlisting}[frame=single]
// MyClass.hpp
class MyClass
{
	bool field_0;
	int field_1;
	std::string field_2;
	std::vector<int> field_3;
};

LIB_REFLECTOR(MyClass, (field_0)(field_1)(field_2)(field_3));

// MyClass.cpp
std::string serialize_my_class(const MyClass& obj)
{
	return lib::json::to_json(obj).to_string();
}

MyClass deserialize_my_class(const std::string& json_text)
{
	return lib::json::from_string(json_text).as<MyClass>();
}
					\end{lstlisting}
					\caption{Przykładowa implementacja funkcji serializacji i~deserializacji za pomocą biblioteki z~pół automatyczną refleksją pól}
					\label{half_automatic_example}
				\end{captioned}
			}
		}

		{
			\subsection{W pełni automatyczna refleksja pól}

			Rozwiązanie koncepcyjnie jest mocno zbliżone do poprzedniego, jednakże ma jedną podstawową różnicę, która rozwiązuje ostatni
			problem dotyczący dodania nowego pola w~klasie. Jest to możliwe, ponieważ architektura oparta o~taką bibliotekę, wymusza wplecenie
			interfejsu biblioteki w~deklarację klasy i~nieoczywiste jest dołożenie nowego pola bez skorzystania z~narzuconego interfejsu, co
			radykalnie redukuje możliwość zaistnienia takiego problemu.\n

			W momencie powstawania tej pracy autor nie ma informacji o~istnieniu takich rozwiązań. Dlatego niniejsza praca ma na celu
			stworzenie takiego rozwiązania, a~także zbadanie wydajności pod kątem czasu wykonania, względem wcześniej wspomnianych rozwiązań.
		}
	}

	{
		\section{Cel i~Zakres Pracy}

		Celem jest przeprowadzenie testów wydajnościowych mających na celu porównanie powszechnie używanych współcześnie bibliotek odpowiedzialnych
		za obsługę serializacji i~deserializacji do formatu \JSON ze stworzoną na potrzeby tej pracy eksperymentalną
		implementacją biblioteką \serek, stworzoną na potrzeby tej pracy.

		{
			\subsection{Implementacja}

			Wyznacznikiem ukończenia implementacji biblioteki, będzie moment pozytywnego wykonania na bieżąco pisanych testów oraz stworzenie zreflektowanego obiektu z~prawidłowego
			ciągu znaków w~formacie \JSON, a~także operacja odwrotna. Celem sformalizowania tego etapu, wymagane jest:

			\begin{itemize}
				\setlength\itemsep{0mm}
				\item zaprojektowanie przyjaznego programiście interfejsu biblioteki
				\item implementacja mechanizmu w~pełni automatycznej refleksji
				\item implementacja mechanizmu serializacji
				\item implementacja mechanizmu deserializacji
				\item implementacja testów potwierdzających działanie powyższych punktów
			\end{itemize}
		}

		{
			\newpage
			\subsection{Badania wydajnościowe}

			Celem sprawdzenia wydajności biblioteki, zostaną w~kontrze przetestowane dwie inne biblioteki. Zostaną one wybrane po jednej do opisanych w~poprzednim rozdziale
			rodzajów podejść do tego tematu. Badania z~ich wykorzystaniem zostaną przeprowadzone w~dedykowanym do takiego celu oprogramowaniu, celem uzyskania jak najbardziej
			rzetelnych wyników. Zakres pracy do wykonania, celem osiągnięcia tego jest:

			\begin{itemize}
				\setlength\itemsep{0mm}
				\item implementacja środowiska do testowania wydajności trzech bibliotek
				\item zaprojektowanie scenariusza testowego tak, aby każda biblioteka była testowana w~sposób izolowany i~jednakowy
				\item implementacja serializacji oraz deserializacji korzystając z~trzech bibliotek
				\item przeprowadzenie badań
				\item analiza uzyskanych danych
			\end{itemize}
		}

	}

	{
		\section{Implementacja biblioteki \serek}\label{serek}

		{
			\subsection{Dobór technologii}

			{
				\subsubsection{Format \JSON}

				Jest lekkim formatem danych wywodzącym się z~języka JavaScript. Jak pokazano na wykresie numer \ref{json_vs_world},
				\JSON jest formatem o~największej rozpoznawalności wśród tekstowych reprezentacji danych. Swój sukces
				zawdzięcza swojej formie: bardzo czytelnej dla człowieka, jednocześnie wydajnej dla komputerów zarówno
				podczas przetwarzania, jak i~generowania. Cecha ta sprawia, że praktycznie każdy współcześnie używany język
				programowania ma jego obsługę\cite{json_short} w~bibliotece standardowej lub posiada zastęp zewnętrznych
				bibliotek.\n

				Poddając \JSON usystematyzowaniu, jest to format danych o~strukturze drzewiastej, który technicznie
				może być zagnieżdżony w~stopniu nieskończonym, w~przeciwieństwie do formatów płaskich, takich jak CSV.\n
			}

			{
				\subsubsection{System budowy oraz środowisko deweloperskie}

				Celem zapewnienia systemu budowy, który jest przystosowany do użycia na wielu platformach, oraz udostępnia narzędzia pozwalające na prostą
				integrację z~innymi bibliotekami, wybór \nonpl{cmake}'a\cite{cmake_docs} jest domyślnym wyborem w~przypadku tej biblioteki, jak i~wielu innych.\n

				Jedną z~głównych zalet tego oprogramowania, jest możliwość rozproszonego definiowania celów budowy. Dzięki takiemu podejściu nie jest tworzony
				jeden wielki plik z~definicją całego projektu, tylko wiele plików, które skupiają się na konfiguracji poszczególnych elementów aplikacji.\n

				Dodatkowo istnieje możliwość tworzenia własnych, niekompilowanych (innych niż pliki wykonywalne, czy biblioteki) celów budowy. Zostało to zagospodarowane
				przez integrację z~różnymi narzędziami wspomagającymi rozwój oprogramowania. Pierwszym z~nich jest system kontroli wersji \nonpl{git}\cite{git_docs}. Oprócz standardowego
				zastosowania podczas wytwarzania oprogramowania został też zintegrowany podczas budowy oprogramowania, automatycznie pobierając wszystkie pakiety zależne
				(\ang{submodules}), dzięki czemu podczas budowy, wszystkie paczki są zaktualizowane.\n

				Kolejnym miejscem jest dodanie statycznej analizy kodu za pomocą programu \nonpl{cppcheck}\cite{cppcheck_repo}, który pomógł znaleźć masę drobnych błędów,
				jak nie zainicjalizowane zmienne, czy funkcje niezwracające żadnej wartości, mimo takiej deklaracji. Dodatkowo udało się wyeliminować kilka funkcji,
				które jak się okazało, były martwym kodem, niewołanym w~żadnym możliwym przejściu.\n

				Następnym oprogramowaniem, które zostało zintegrowane z~systemem budowy, to narzędzie formatujące kod \nonpl{clang-format}\cite{clangformat_docs}, dzięki czemu
				udało się trzymać jednolity format kodu. Oprócz samych względów estetycznych samo narzędzie potrafi pomóc w~znajdywaniu prostych błędów, polegających
				na braku klamry, czy średnika, ponieważ w~okolicy literówki, najczęściej formatowanie jest wyraźnie inne i~przykuwa to wzrok podczas poszukiwań.\n

				Ostatnim zintegrowanym narzędziem deweloperskim jest automatyczne generowanie interaktywnej dokumentacji w~formie gotowej strony www. Poniżej zrzuty
				ekranu prezentujące wygląd wygenerowanej dokumentacji (rysunek \ref{docs_1} i~\ref{docs_2}).\n

				\putss{./img/documentation_part_1.png}{Widok automatycznej dokumentacji na spis wszystkich przestrzeni nazw w~projekcie wraz z~krótkim opisem}{docs_1}
				\putss{./img/documentation_part_2.png}{Widok automatycznej dokumentacji na opis funkcji \code{serek::require}}{docs_2}

				\newpage

				Całość opiera się o~narzędzie \nonpl{Doxygen}\cite{doxygen_docs}, które za pomocą specjalnych komentarzy w~kodzie, pokazanych na rysunku numer \ref{doxygen_code},
				jest w~stanie wygenerować różnego rodzaju dokumentację. Wspomniane komentarze umieszczone są powyżej deklaracji (w~tym wypadku również definicji) i~zawierają
				opisy parametrów szablonów (\code{@tparam}) oraz argumentów funkcji (\code{@param}). Dodatkowo w~sekcji wyróżnionej za pomocą znacznika \code{@brief}, został
				umieszczony skrócony opis funkcji. Jeżeli opisywany obiekt zwracałby jakąś wartość jest również możliwe opisanie zarówno typu jak i~znaczenia zwracanych wartości
				za pomocą znacznika \code{@returns}.\n

				\begin{captioned}[H]
					\begin{lstlisting}[frame=single]
/**
* @brief overload of above, allows additionally print given values
*
* @tparam operator_t functor that will be used for comparison @see @link https://en.cppreference.com/w/cpp/utility/functional/less @endlink
* @tparam T type of compared elements
* @param l_value left operand
* @param r_value right operand
* @param error_message message to forward to exception
*/
template<template<typename T> typename operator_t, typename T>
void require(const T& l_value, const T& r_value, const str_v error_message = "comparison failed!")
{/* implementation */}

/**
* @brief overload of above, specialized for checking pointers
*
* @tparam pointer_t type of pointer to validate
* @param ptr pointer to check
* @param error_message message to forward to exception
*/
template<reqs::comparable_as_pointer_req pointer_t>
void require(const pointer_t& ptr, const str_v error_message = "given pointer was null!")
{/* implementation */}
					\end{lstlisting}
					\caption{ Udokumentowane funkcje zgodnie ze standardem \nonpl{Doxygen}}
					\label{doxygen_code}
				\end{captioned}
			}
		}

		{
			\subsection{Problematyka i~wyzwania podczas implementacji}

			Problematyka całego podejścia jest dwuwymiarowa, ponieważ istnieje konieczność stworzenia interfejsu biblioteki, która wykluczy, lub znacząco
			zredukuje możliwość wystąpienia wcześniej wspomnianych przeszkód. Dodatkowo należy przewidzieć możliwość zadawania własnych metod serializacji,
			najlepiej w~jednolity sposób. Poza tymi wymaganiami został sformułowany jeszcze jeden warunek dla całej implementacji: brak korzystania z~makr.\n

			Jak zostało wspomniane w~rozdziale poświęconym omówieniu definicji refleksji, język C++ nie posiada zbyt dużego wsparcia dla programowania
			refleksyjnego. Będzie to wyzwanie ściśle techniczne, a~dokładnie implementacyjne. Rozwiązanie tego wyzwania daje bardzo wymierne korzyści,
			ponieważ otwiera to drzwi do całej gamy rozwiązań z~serializacji, nie tylko w~formacie \JSON, ale także do takich formatów jak SQL, czy
			postać binarna.\n

			Intuicyjnym podejściem wydaje się wykorzystanie wzorca projektowego polegającego na przekazaniu klasie rodzica, typu klasy dziecka - \nonpl{CRTP}
			(\ang{curiously recurring template pattern}). Umożliwiałoby to potencjalnie abstrakcję niezbędnych narzędzi do przejścia po polach klasy dziecka u~rodzica.
			To podejście jest skazane na porażkę. Jest to spowodowane miejscem korzystania z~tego wzorca, a~mianowicie, przy samej deklaracji klasy, co jest zbyt wczesnym etapem,
			gdy pola nie są jeszcze zdefiniowane. Dodatkowo to rozwiązanie, gdzie wszystkie pola byłyby wymienione jako referencje u~rodzica ma jeszcze jedną, jak zresztą każde
			inne rozwiązanie opierające się na wymienieniu w~sekwencji wszystkich pól, wadę: nie eliminuje wciąż problemu gapiostwa programisty, który mógłby zapomnieć
			dopisać nowe pole w~strukturze danych, dlatego zaszła konieczność wplecenia interfejsu pomiędzy deklaracje pól klasy.
		}

		{
			\subsection{Architektura}

			Rozwiązaniem bolączek wspomnianych w~poprzednim rozdziale jest zastosowanie autorskiego rozwiązania: statycznej listy jednokierunkowe, na podstawie
			referencji do pól klasy. Podejście to wykorzystuje fakt, że dostęp do referencji do pola numer jeden uzyskujemy w~momencie postawienia średnika przy jego deklaracji.
			Dlatego najwcześniej, gdy się da do takiego pola odwołać, jest deklaracja następnego pola, lub zewnętrze klasy, które również zostanie tutaj zagospodarowane,
			ale nieco inaczej niż we wcześniej wspomnianej pół automatycznej refleksji typów. Jeżeli więc pociągnąć ten koncept dalej, gdzie pole drugie wskazuje, na
			pole pierwsze, a~pole trzecie na drugie i~tak dalej. Taka klasa staje się w~ten sposób listą jednokierunkową, której zakończeniem jest pierwszy członek klasy.
			Rozwiązanie to już koncepcyjnie rozwiązuje największą bolączkę poprzednich rozwiązań: oderwanie miejsca refleksji od bieżącego stanu klasy.
			Teraz każde pole przy deklaracji wskazuje na poprzednie, jest więc to rzucające się w~oczy, przy dodawaniu lub usuwaniu pól klasy, nie do pominięcia.\n

			Jednakże przejście jednej przeszkody stwarza kolejne. Pierwszym jest rozwiązanie problemu dostępu do właściwych typów pod kolejnymi polami, a~także
			miejscem na przechowywanie referencji, która mogłaby sprawić, że cała klasa przytyje w~zależności od środowiska o~$N * 8$, lub $N * 4$ bajty,
			gdzie $N$ jest liczbą pól. Dodatkowo wciąż jest problem z~początkiem listy, czyli referencją na ostatnie pole klasy. O~ile koniec jest oczywisty,
			w postaci pierwszego pola, to początek już nie i~wymaga osobnego zainteresowania. Kolejnym kłopotem jest miejsce pobrania nazwy pola, co jest
			konieczne, aby móc zbudować obiekt \JSON, gdzie we wcześniej prezentowanych rozwiązaniach użytkownik sam deklarował nazwę pola, lub nazwa ta
			była w~prosty sposób wyłuskiwana przez makro.\n

			{
				\subsubsection{Problem dostępu do wartości pola}

				Rozwiązania są co najmniej dwa. Pierwszym, które nie zostało wybrane, to skorzystanie z~interfejsu, jakie oferują wskaźniki. Oznacza to,
				przechowywanie wartości jako pole jakiejś obwoluty (\ang{wrapper}), a~dostęp do niego poprzez operator dostępu do pola $\rightarrow$. Jednakże problemem
				tego rozwiązania jest przeniesienie odpowiedzialności za zaimplementowanie wszystkich operatorów, konstruktorów, czy destruktorów
				na klasę otaczającą, oraz poprawne ich przekazanie do klasy wewnątrz. Przy tym podejściu ryzyko popełnienia gafy jest bardzo wysokie, dlatego też
				pojawiła się kolejna koncepcja.\n

				Polega ona na zaciągnięciu do pracy wcześniej wspomnianego wzorca \CRTP, oraz publiczne dziedziczenie po każdym polu, co sprawiłoby, że
				interfejs zostaje identyczny, dla dowolnej klasy, a~jedyne co pozostaje do zaimplementowania, to poprawne przekierowanie konstruktorów
				i destruktorów.\n

				Jednakże C++ jest językiem, gdzie istnieje rozróżnienie na typy złożone i~proste, po których nie można dziedziczyć. Aby pokryć ten przypadek,
				można skorzystać z~rozbudowanego modułu do metaprogramowania w~języku C++ i~napisać dwie specjalizacje. Jedna dla typów prostych, w~dużym stopniu
				korzystając z~opisanego wcześniej rozwiązania, gdzie ilość rzeczy do przekierowania, nie jest tak duża. Drugą zaś, dla typów złożonych,
				gdzie można wykorzystać wcześniej wspomniany wzorzec \CRTP i~dziedziczyć po typach złożonych, takich jak klasa, czy struktura.\n

				Dzięki skorzystaniu ze struktury \code{std::is\_fundamental\_v<T>}\cite{std_is_fundamental}, za pomocą której jest możliwe wyciągnięcie informacji,
				czy typ jest prosty, czy nie. Co więcej, dzięki wprowadzeniu operatora potrójnego porównania \cite{starship_operator} w~standardzie C++20, możliwe było
				przyspieszenie procedury przekierowywania operatorów poprzez przeciążenie wyłącznie jednego. Dodatkowo dodanie cichych konwersji dodatkowo redukuje
				dyskomfort w~korzystaniu z~fasady. Implementacja tego typu ma jeszcze jedną bardzo ważną zaletę: jest fasadą idealną, która może zostać przekazana jako referencja
				do klasy, którą opakowuje.
			}

			{
				\subsubsection{Problem przechowywania referencji}

				Poprzednie rozwiązanie w~przypadku typów prostych umożliwia bardzo proste dodanie dodatkowego pola z~referencją. Jednakże rozwiązanie to:
				po pierwsze przywołuje problem z~puchnięciem klasy z~każdym dodatkowym polem, a~po drugie mocno komplikuje rozwiązanie z~dziedziczeniem po
				typach złożonych, gdzie naruszenie bazowego interfejsu poprzez dołożenie nowej zmiennej, czy metody naruszałoby wrażenie przeźroczystości
				biblioteki.\n

				Aby zaproponować rozwiązanie, należy podać definicję statycznej referencji na pole klasy. Otóż jest to przesunięcie względem
				adresu struktury danych. Wynika więc z~tej definicji, że jest to wartość możliwa do określenia, jeszcze podczas kompilacji,
				a to zaś implikuje możliwość przekazania go jako argument szablonu. Co jak się okazuje, jest możliwe. Dzięki czemu została rozwiązana przeszkoda
				przechowywania adresu do poprzedniego pola klasy, jest on po prostu przechowywany jako liczba (przesunięcie) z~typem poprzedniego pola w~klasie.\n

				Teraz, żeby dostać się do pola, potrzebny jest wskaźnik na obiekt (\code{this}), a~następnie dodanie do niego posiadanego przesunięcia.
				Dodatkowo rozwiązane zostaje tutaj jeszcze jedno wyzwanie, a~mianowicie problem z~dostępem do nazwy pól.
			}

			{
				\subsubsection{Problem dostępu do nazwy pola}

				Celem pokazania, w~jaki sposób następuje dostęp do nazwy pola i~jednocześnie podsumowania aktualnej architektury, na rysunku numer \ref{serek_summary} zamieszczony
				został przykład zapisu na podstawie poprzednich kilku akapitów, gdzie należy zwrócić uwagę na definicje typów kolejnych pól.\n

				\begin{captioned}[H]
					\begin{lstlisting}[frame=single]
struct test_struct
{
	first_field<int> field_0;
	field<&test_struct::field_0, float> field_1;
};
					\end{lstlisting}
					\caption{ Szkicowy zapis biblioteki w~pełni automatycznej refleksji, na podstawie dotychczasowych akapitów}
					\label{serek_summary}
				\end{captioned}


				Jak można zauważyć, celem odwołania się do referencji na poprzednie pole, konieczne jest odwołanie się do jego nazwy. Nie pozostaje to bez
				konsekwencji, które można wykorzystać, a~zostanie to zaprezentowane, poprzez zamieszczenie kodu na rysunku numer \ref{typename_example}, który
				ma na celu wydrukować na ekranie rozczesywany (\ang{demangled}) typ pola \code{field\_1}, a~także wyjście z~tego prostego programu:\n

				\begin{captioned}[H]
				\begin{lstlisting}[frame=single]
#include <serek/serek.hpp>

struct test_struct
{
	serek::ffield<int> field_0;
	serek::field<&test_struct::field_0, float> field_1;
};

int main()
{
	std::cout << serek::type_name<decltype(&test_struct::field_1)>() << std::endl;
}
/*
Konsola:
	serek::detail::field_impl<&test_struct::field_0, double> test_struct::
*/
				\end{lstlisting}
				\caption{ Prosty program wraz z~wyjściem ilustrujący źródło wyodrębniania nazw pól}
				\label{typename_example}
			\end{captioned}

				Wydobycie nazwy pola może nastąpić z~rozczesanej nazwy pola, którą bajecznie prosto uzyskać, ponieważ jest ona zawarta
				w tekstowej reprezentacji szablonu.
			}

			{
				\subsubsection{Problem punktu startowego}

				Wcześniej wspomniane wybory umożliwiły rozwiązanie wielu problemów i~wyzwań. Zawarcie referencji do ostatniego pola
				struktury danych wewnątrz klasy okazało się nie możliwe, bez odbierania użytkownikowi biblioteki pewnych funkcjonalności.
				Przekazywanie za pomocą wzorca projektowego \CRTP nie jest możliwe przy deklaracji klasy z~wcześniej wspomnianych powodów.\n

				Rozwiązanie to tworzenie aliasu docelowej nazwy klasy zaraz pod definicją klasy, zawierając w~niej statyczną referencję do ostatniego pola klasy.
				Takie rozwiązanie daje maksimum elastyczności użytkownikowi, a~także nie wprowadza żadnego zaburzenia w~interfejs tworzonej klasy.\n

				Sam alias również nie jest do końca taki prosty, ponieważ korzysta z~podobnej sztuczki co klasa odpowiedzialna, za przechowywanie
				kolejnych pól w~klasie. Precyzując: dziedziczy po klasie, do której należy ostatnie pole klasy, dzięki czemu całość zostaje
				zapakowane w~fasadę idealnie przeźroczystą z~wygodnym dostępem do każdego pola w~klasie. Na rysunku \ref{serek_full_example} urzeczywistniony,
				przykład deklaracji klasy.\n

				\begin{captioned}[H]
					\begin{lstlisting}[frame=single]
#include <serek/serek.hpp>

struct test_struct_impl
{
	serek::ffield<int> field_0;
	serek::field<&test_struct_impl::field_0, float> field_1;
	serek::field<&test_struct_impl::field_1, double> field_2;
};
using test_struct = serek::pack<&test_struct_impl::field_2>;
					\end{lstlisting}
					\caption{ Pełna definicja struktury, korzystając z~biblioteki \serek}
					\label{serek_full_example}
				\end{captioned}
			}

			{
				\subsubsection{Problem prostej podmiany sposobu obsługi typu}

				Jest to ostatni z~naczelnych problemów, wymienionych na przestrzeni poprzednich akapitów. Rozwiązanie tego wyzwania,
				wymagało przemyślenia, lokalizacji kodu od serializacji i~deserializacji, oraz sposobu na przemieszczanie się po takiej
				statycznej jednokierunkowej liście pól w~klasie.\n

				Umieszczenie kodu od obsługi konkretnych typów, wydaje się najprościej umieścić w~specjalizacjach dla konkretnych typów.
				Ma to kilka nieporządnych konsekwencji. Pierwszą jest taka, że wymagałoby to tworzenia częściowych specjalizacji, co
				wymuszałoby umieszczanie takiego kodu w~całości w~plikach nagłówkowych. Zdecydowanie wydłużałoby to czas kompilacji
				i~sprawiałoby, że sporo kodu, który powinien się znaleźć w~plikach źródłowych, lądowałby w~nagłówkach. Dodatkowo
				usztywniłoby to całą bibliotekę, ponieważ kod byłby za daleko od użytkownika, a~jego nadpisanie poprzez na przykład
				przeciążenie funkcji dla danego typu czasochłonne, ponieważ musiałby się wdrażać w~skomplikowaną implementację klas
				przechowujące pola, czy klasy.\n

				Dlatego koniecznością stało się wydzielenie kodu od serializacji do osobnej klasy. Szczęśliwie, istnieje wzorzec projektowy,
				który bardzo dobrze sprawdza się w~przypadku konieczności wydzielenia funkcjonalności poza klasę - wizytator\cite{visitor_description}.
				Użycie go w~przypadku tej implementacji jest bardzo proste i~intuicyjne. Biblioteka zapewnia klasę bazową, po której dziedzicząc,
				użytkownik tworzy własnego wizytatora, w~którym definiuje obsługę swoich typów, jako przeciążenia operatora wywołania (\code{operator()}),
				natomiast, wszystkie pozostałe przekierowuje do klasy bazowe, która ma zaimplementowane obsługę typów fundamentalnych.\n

				\begin{captioned}[H]
					\begin{lstlisting}[frame=single]
struct hash_json_serializer : public serek::deserial::json::json_visitor_deserializer
{
	serek::visitor_result_t operator()(hash_t& any)
	{
		any = hash_t::from_string(this->get_top_token());
		return true;
	}
};
					\end{lstlisting}
					\caption{ Przykład implementacji wizytatora, spełniającego wymagania biblioteki \serek, wraz z~zdefiniowaną obsługą własnego typu \code{hash_t}}
					\label{visitor_ex}
				\end{captioned}

				Przykład na rysunku numer \ref{visitor_ex} jest gotowym do użycia wizytatorem na dowolnym obiekcie poddanym refleksji, przez bibliotekę
				\serek . Można go użyć za pomocą dostarczonej funkcji \code{serek::visit}, gdzie pierwszym parametrem jest obiekt, na którym
				chcemy dokonać operacji serializacji lub deserializacji, natomiast drugim parametrem jest wizytator.
			}
		}

		{
			\subsection{Potencjalne zalety}

			Wykorzystanie szablonowego metaprogramowania\cite{wiki_meta} ma dwie naczelne funkcje w~języku C++. Pierwszą z~nich jest
			ta najbardziej praktyczna umożliwiająca redukcję pisanego kodu, poprzez jego umiejętne sformułowanie, tak aby kompilator
			sam wygenerował odpowiednie fragmenty. Drugą, często niedocenianą zaletą takiego podejścia, jest możliwość wykorzystania
			potencjału i~wiedzy zgromadzonego w~kompilatorze przez dziesiątki lat rozwoju. Im bardziej programista odda ster
			kompilatorowi, tym większa jest szansa na pojawienie się z~punktu widzenia programisty, spontanicznej lub nieoczywistej
			optymalizacji. Ponieważ cała implementacja opiera się w~głównej mierze o~ten paradygmat i~stara się mocno korzystać
			z~rozwiązań takich jak wyrażenia stałe (\ang{constexpr}), czy koncepty, daje kompilatorowi spore pole do wykazania się
			i~redukcji czasu wykonania.
		}
	}

	{
		\section{Testy wydajnościowe}

		Celem sprawdzenia implementacji pod kątem wydajności, przeprowadzono badania w~środowisku, gdzie biblioteki pozwalające na przetwarzanie
		formatu \JSON mogą się najbardziej wykazać, czyli na wejściu i~wyjściu serwerów sieciowych, w~tym wypadku \HTTP. Jak zostało wspomniane
		na samym wstępie, pochodzący z~języka \nonpl{JavaScript} format jest najpowszechniejszym formatem \cite{google_trends_json_api_vs_rest_of_the_world}
		używanym do wymiany danych pomiędzy aplikacjami na warstwie sieciowej.

		{
			\subsection{Środowisko testowe}

			Całe środowisko testowe składa się z~trzech elementów. Pierwszym z~nich są metody posiadające implementację serializacji i~deserializacji
			wykorzystując w~tym celu trzy różne biblioteki, reprezentujące trzy podejścia do tej tematyki. Drugim elementem jest serwer http, którego
			naczelnym zadaniem jest bycie jednakowo pośrednikiem wymiany danych pomiędzy bibliotekami a~oprogramowaniem testującym wydajność oraz
			emulatorem środowiska, w~jakim biblioteki tego typu są najczęściej wykorzystywane. Trzecim i~ostatnim elementem całego systemu jest
			oprogramowanie do testów wydajnościowych, które posiada szereg narzędzi dedykowanych tego typu badaniom.

			{
				\subsubsection{Serwer}

				Jako dostawce usług serwerowych, zdecydowano się na wykorzystanie biblioteki \nonpl{Drogon}\cite{drogon}. Jak sami autorzy twierdzą,
				jest to biblioteka pisana między innymi w~standardzie C++ 20, czyli obecnie najwyższym stabilnym. Posiada prosty interfejs oraz
				wsparcie dla najnowszych zdobyczy języka, takich jak korutyny czy widoki.\n

				Dodatkowo biblioteka ta oparta jest o~system budowy użyty przez bibliotekę \serek, co zdecydowanie uprości integrację. Ponadto
				cała biblioteka jest dostarcza ze skonfigurowaną biblioteką \nonpl{jsoncpp}\cite{jsoncpp_repo}, która zostanie wykorzystana jako
				reprezentant podejścia z~manualną refleksją pól.\n

				Ostatecznie smoczy zasób wymusza na użytkowniku stosowanie się do nowoczesnych wzorców architektonicznych, jakim jest \nonpl{MVC}\cite{mvc}.
				Sprawia to, że cała biblioteka jest w~peletonie pod względem współczesnego podejścia do rozwiązań serwerowych.
			}

			{
				\subsubsection{Model danych}

				Żeby przetestować możliwości bibliotek, zarówno pod kątem wydajności, jak i~elastyczności, na różne struktury danych,
				również model, który będzie podlegał zarówno serializacji, jak i~deserializacji musiał być nieco bardziej zróżnicowany.
				Na całość składa się kombinacja trzech klas, które posiadają relację dziedziczenia oraz kompozycji. Co więcej, aby przy
				testach uwzględnić typy tablicowe, zostały one zawarte jako tablice typów prostych, jak również złożonych. Diagram UML prezentujący
				cały model danych został umieszczony poniżej na rysunku numer \ref{uml_diagram}.

				\putfig{./img/benchmark_model_uml_diagram.png}{Diagram UML prezentujący model testowych danych}{uml_diagram}
			}

			{
				\subsubsection{Biblioteki}

				Podejście z~manualną refleksją pól, będzie miało swojego reprezentanta w~postaci wcześniej wspomnianej biblioteki \nonpl{jsoncpp}.
				Posiada ona standardowy interfejs wśród przedstawicieli swojej kategorii. Na rysunku numer \ref{jsoncpp_impl} zostanie zamieszczony jedynie fragment
				implementacji serializacji, gdzie widać serializację kolejnych pól klasy \code{B}. Objętość koniecznego kodu, aby dorównać funkcjonalnością pozostałym bibliotekom,
				jest zdecydowanie największa. Cała zajmuje obszar w~pliku \nonpl{benchmarks/controllers/benchmark\_controllers.cpp} pomiędzy $26$ a~$141$ wierszem,
				dając sumarycznie $115$ linii kodu.\n

				\begin{captioned}[H]
					\begin{lstlisting}[frame=single]
// ...
json["b1"] = Json::Value(Json::ValueType::arrayValue);
json["b1"].resize(in.b1.size());
for(const auto& it: in.b1) json["b1"].append(it);

json["b2"] = Json::Value(Json::ValueType::arrayValue);
json["b2"].resize(in.b2.size());
for(const auto& it: in.b2) json["b2"].append(it);

json["b3"] = Json::Value(Json::ValueType::arrayValue);
json["b3"].resize(in.b3.size());
for(const auto& it: in.b3)
{
	Json::Value it_result;
	serial_A(it_result, it);
	json["b3"].append(it_result);
}
// ...
					\end{lstlisting}
					\caption{ Fragment implementacji serializacji przy wykorzystaniu biblioteki \nonpl{jsoncpp}}
					\label{jsoncpp_impl}
				\end{captioned}

				Druga biblioteka, jaka będzie uwzględniona podczas testów, jest biblioteka \nonpl{fc}\cite{fc_repo}, która w~dużej mierze jest obwolutą biblioteki
				\nonpl{Boost}\cite{boost}. Jednakże w~zakresie przetwarzania formatu \JSON zapewnia własną implementację. Jej główną wadą są obiekty pośrednie
				w postaci wariantów oraz zmiennych obiektów wariantowych (\ang{mutable variant object}), które z~jednej strony zwiększają narzut konwersji,
				jednakże z~drugiej strony dają sporą elastyczność w~zakresie tworzenia dowolnie zagnieżdżonych obiektów.\n

				Ciekawsze fragmenty dotyczące tej implementacji znajdują się w~pliku nagłówkowym (rysunek \ref{fc_impl_header}), gdzie dokonana jest
				pół automatyczna zewnętrzna refleksja pól wszystkich klas modelu (\code{FC\_REFLECT} oraz \code{FC\_REFLECT\_DERIVED}). Same metody
				deserializacji oraz serializacji są w~odpowiadającej kolejności umieszczone w~całości na rysunku numer \ref{fc_impl_source}.\n

				\begin{captioned}[H]
					\begin{lstlisting}[frame=single]
// fc_benchmark_controller.hpp
//...

FC_REFLECT(fc_model_t::A, (a1)(a2)(a3)(a4)(a5));
FC_REFLECT(fc_model_t::B, (b1)(b2)(b3));
FC_REFLECT_DERIVED(fc_model_t::C, (fc_model_t::A), (c1)(c2));
					\end{lstlisting}
					\caption{ Fragment nagłówka z~definicją refleksji przy wykorzystaniu biblioteki \nonpl{fc}}
					\label{fc_impl_header}
				\end{captioned}

				Biblioteka w~głównej mierze bazuje na makrach, które są rozwijane do specjalizacji klasy \code{fc::reflector}, która później jest
				wykorzystywana przy refleksji podczas przejść z~i na formę tekstową. Stosowana jest tutaj notacja listy bąbelkowej, która umożliwia
				tworzenie wielu list w~zakresie jednego makra. Ostatnim elementem podczas omawiania tej biblioteki jest prezentacja implementacji metod.\n

				\begin{captioned}[H]
					\begin{lstlisting}[frame=single]
void fc_benchmark_controller::deserialize(model_t& out, const std::string_view in) const
{
	const auto& variant = fc::json::from_string(std::string{in.data(), in.size()});
	const auto& obj	    = variant.get_object();
	fc::reflector<model_t>::visit(fc::from_variant_visitor<model_t>(obj, out, 10));
}

void fc_benchmark_controller::serialize(const model_t& in, std::string& out) const
{
	fc::mutable_variant_object mvo{};
	fc::reflector<model_t>::visit(fc::to_variant_visitor<model_t>(mvo, in, 10));
	out = fc::json::to_string(mvo);
}
					\end{lstlisting}
					\caption{ Implementacje funkcji do serializacji i~deserializacji przy wykorzystaniu biblioteki \nonpl{fc}}
					\label{fc_impl_source}
				\end{captioned}

				Sama biblioteka dominuje ponad sześciokrotnie mniejszym, objętościowo kodem wymaganym do przeprowadzenia implementacji
				serializacji oraz deserializacji. Kompaktowość tego rozwiązania uwypukla zalety programowania refleksyjnego, które dzięki
				możliwości spojrzenia w~siebie (refleksji) daje możliwość znaczącej redukcji kodu.\n

				Trzecią i~jednocześnie ostatnią biblioteką jest opisana szerzej w~rozdziale numer \ref{serek} - biblioteka \serek.
				Jej użycie jest jeszcze krótsze (patrz rysunek numer \ref{serek_impl_source}) i~doliczając dodatkowe wiersze na aliasy,
				całość zamyka się w~zaledwie $12$ liniach kodu.\n

				\begin{captioned}[H]
					\begin{lstlisting}[frame=single]
void serek_benchmark_controller::deserialize(model_t& out, const std::string_view in) const
{
	serek::deserial::json::deserialize<model_t>(in, out);
}

void serek_benchmark_controller::serialize(const model_t& in, std::string& out) const
{
	out = serek::serial::json::serialize(in);
}
					\end{lstlisting}
					\caption{ Implementacje odpowiednio funkcji do deserializacji i~serializacji przy wykorzystaniu biblioteki \serek}
					\label{serek_impl_source}
				\end{captioned}
			}

			{
				\subsubsection{Oprogramowanie do testów wydajnościowych}

				\Jmeter\cite{jmeter} jest oprogramowaniem stworzonym przez fundację \nonpl{Apache}, napisaną w~języku \nonpl{Java}. Jej przeznaczeniem
				jest projektowanie oraz wykonanie testów wydajnościowych. Sam wachlarz możliwości, jakie oferuje, rozpościera się od prostego odpytywania serwisu, poprzez
				tworzenie złożonych wielokrotnie zagnieżdżonych struktur warunkowych i~pętel wykonujących wielokrotne logowania kończąc na tworzeniu interaktywnych
				raportów w~formie stron wwww. Specyfika tego badania wymaga jedynie części z~wymienionych powyżej możliwości.

				\putss{./img/jmeter_ss/main_pane.png}{ Widok ogólnej konfiguracji całego testu}{jmeter_main_config}

				Pierwszy panel do konfiguracji (rysunek numer \ref{jmeter_main_config}), pozwala wybrać sposób uruchamiania kolejnych grup wątków. Została wybrana opcja,
				aby testy były uruchamiane sekwencyjnie, co sprawi, że wydzielone grupy wątków dla każdej z~bibliotek nie będą na siebie wpływać.\n

				\putss{./img/jmeter_ss/thread_group_config.png}{ Konfiguracja grupy wątków}{jmeter_thread_config}

				Ustawienia każdej z~trzech grup wątków (rysunek \ref{jmeter_thread_config}) są takie same. Pozwalają sprecyzować ilość zapytań na każdym z~uruchamianych wątków, a~także ile ma się ich pojawić.
				Ustawienie ilości zapytań na wartość ujemną sprawi, że zapytania będą wysyłane w~sposób ciągły do momentu wystąpienia punktu przerwania, na przykład czas, czy warunkowa
				ilość powtórzeń. Na powyższym zrzucie ekranu jednak nie widnieją żadne liczby, jest to spowodowane możliwością tworzenia zmiennych i~odnoszenia się do nich w~dowolnym innym
				komponencie.\n

				\putss{./img/jmeter_ss/variables.png}{ Konfiguracja zmiennych}{jmeter_var_config}

				Tworzenie zmiennych odbywa się w~dedykowanym widoku, przedstawionym na rysunku numer \ref{jmeter_var_config}. Istnieje możliwość przypisania nazw zmiennym, określenia ich wartości,
				a~także zapisania krótkiego tekstu pomocy. Tajemniczy zapis w~kolumnie wartości jest spowodowany sposobem uruchamiania testów wydajnościowych za pomocą programu \Jmeter,
				ponieważ powinno się to odbywać z~poziomu terminala, o~czym informuje nas sama aplikacji podczas jej uruchomienia w~sposób przedstawiony na rysunku numer \ref{jmeter_warn}.
				Uruchomienie z~poziomu terminala daje możliwość nadpisania domyślnych wartości poprzez dodanie odpowiednich parametrów do polecenia (za pomocą flagi \code{-J nazwa\_pola=nowa\_wartość}).\n

				\putss{./img/jmeter_ss/jmeter_gui_warn.png}{ Ostrzeżenie dotyczące nieprzeprowadzania testów wydajnościowych w~trybie graficznym}{jmeter_warn}

				Następną rzeczą wymagającej konfiguracji, jest źródło danych dla zapytań. Ponieważ algorytm serwera został napisany, tak aby najpierw zdeserializował otrzymaną
				wiadomość do wyżej opisanej struktury danych, następnie zserializował ponownie, by finalnie zwrócić tak przepakowane zapytanie jako odpowiedź. Źródła wejścia danych
				zostało zdefiniowane jako plik \nonpl{CSV}, którego każdy podzielony na tokeny wiersz jest przekazywany do każdego wątku niezależnie od siebie. Dzięki takiemu rozwiązaniu
				każda biblioteka zostanie uczciwie przetestowana takim samym zestawem danych. Na rysunku numer \ref{jmeter_config_csv} zostały przedstawione udostępnione opcje przez środowisko testowe.\n

				\putss{./img/jmeter_ss/csv_config.png}{ Konfiguracja punktu źródła danych do zapytań}{jmeter_config_csv}

				Ostatnimi miejscami do uzupełnienia jest globalna konfiguracja klienta \HTTP (rysunek numer \ref{jmeter_config_http}) oraz sprecyzowanie ścieżek, pod jakimi dostępne są konkretne biblioteki.\n

				\putss{./img/jmeter_ss/http_serek_config.png}{ Konfiguracja klienta \HTTP dla biblioteki \serek}{jmeter_config_http}

				Konfiguracja zostaje dokończona, poprzez uruchomienie testów wydajnościowych na bardzo małej próbie zaledwie stu próbek
				na każdej bibliotece. Zaglądając do zakładki z~agregowanym raportem, można podejrzeć szybkie statystyki stworzone przez aplikację. Wyświetlone
				zostają informacji między innymi o~ilości próbek wysłanej do każdej biblioteki, najkrótszym, najdłuższym, średnim oraz środkowym czasie. Wyniki
				zostają zaprezentowane w~formie tabeli, tak jak na rysunku numer \ref{jmeter_report}.\n

				\putss{./img/jmeter_ss/aggregate_report.png}{ Szybki raport wygenerowany przez aplikację}{jmeter_report}
			}

			{
				\subsubsection{Konfiguracja}

				Konfiguracja całego środowiska została dobrana tak, aby nie doprowadzić do wpływu warunków zewnętrznych na pomiary. Rozpoczynając od infrastruktury sieciowej:
				wybranie wyłącznie lokalnego interfejsu sieciowego, następuje izolacja od wpływu warstwy transportowej w~postaci urządzeń sieciowych czy ruchu innych urządzeń.
				Dodatkowo zarówno klient, jak i~serwer nie znajdują się w~środowiskach wirtualnych, czy emulowanych, więc nie zostaje dołożony narzut wirtualnych kart sieciowych.\n

				Zestaw testujący został wygenerowany za pomocą dedykowanego skryptu w~języku \nonpl{Python}. Składał się on z~$10'000$ próbek w~postaci poprawnych zserializowanych
				reprezentacji w~formacie \JSON wyżej przedstawionego modelu (patrz rysunek \ref{uml_diagram}). Każda zajmuje dokładnie jedną linijkę o~średniej długości $266'436$ bajtów.
				Każda z~wygenerowanych tablic posiada długość $1'000$ elementów, natomiast każda liczba została wygenerowana na pełnym swoim zakresie, zależnym od typów.\n

				Sam serwer \HTTP został tak skonfigurowany, aby domyślne mechanizmy optymalizujące i~zabezpieczające nie interferowały w~pomiary. Oznacza to rezygnację z~szyfrowania,
				a także mechanizmu \nonpl{CORS}. Jednakże eliminacja czynników potencjalnie spowalniających cały proces to nie koniec. Wymagane jest również wyeliminowanie
				czynników mogących przyspieszyć działanie serwisu. Takim mechanizmem jest pamięć podręczna (\ang{cache}), która została wyłączona. Kolejnym elementem, który mógłby mieć negatywny
				wpływ na wyniki, jest ustawienie obsługi nagłówka \code{Keep-Alive}. Czas podtrzymania połączenia został wydłużony maksymalnie, celem eliminacji narzutu wynikającego
				z~tworzenia i~zamykania połączenia.\n

				Konfiguracja strony klienckiej była bardzo prosta, ponieważ ograniczyła się wyłącznie do wykorzystania wspomnianego powyżej mechanizmu podtrzymania sesji. Natomiast,
				zgodnie z~rekomendacją oprogramowania \Jmeter, klient podczas testu wydajnościowego został uruchomiony w~trybie niegraficznym.\n

				Ostatnim elementem był system operacyjny, któremu należało oznajmić, że oba procesy będą bardzo ważne i~nie należy im przeszkadzać podczas ich istnienia. Zostało to
				osiągnięte poprzez ustawienie obu procesom (oraz ich wątkom) najwyższe możliwe priorytety, poprzez komendę \code{renice -20 <pid>}.
				Także sama maszyna nie miała innych obciążających aplikacji włączonych w~tle.
			}
		}

		{
			\subsection{Wyniki}

			{
				\subsubsection{Surowe dane}

				Prezentacja danych powinna się rozpocząć od przeglądu ogólnych charakterystyk zbioru. Poniżej kilka wykresów, obrazujących zebrane dane.
				Pierwsze dwa prezentują wartości w~milisekundach, odnosząc się do czasu trwania opisanej operacji. Dwa kolejne prezentują wartości skumulowane
				w~postaci przepustowości, określanej jako ilość zapytań na sekundę. W~przypadku tych ostatnich trzeba zaznaczyć, że dziedzina (sekunda trwania testu),
				została skrócona o~wartość pierwszą i~ostatnią, jest to spowodowane metodologią wyliczania, gdzie od czasu zapytania (w milisekundach) był odejmowany
				czas pierwszego pomiaru, a~następnie dochodziło do zaokrąglenia do pełnych sekund, uzyskując w~ten sposób przyporządkowanie każdego pomiaru do konkretnej sekundy trwania testu.
				Ponieważ test nie zaczynał się o~okrągłej sekundzie, ilość zapytań w~pierwszej i~ostatniej sekundzie była wartością skrajną (zdecydowanie mniejszą niż reszta pomiarów).

				{
					\putfig{./charts/pre_generated_charts/total_request_time_per_library_summary.png}{
						Zestawienie agregowanych charakterystyk opisujących całkowity czas wykonania zapytania, dla różnych bibliotek
					}{sumfig_1}
				}

				{
					\putfig{./charts/pre_generated_charts/total_serial_and_deserial_library_summmary.png}{
						Zestawienie sumarycznych czasów serializacji, deserializacji, całego zapytania oraz ich różnicy
					}{sumfig_2}
				}

				{
					\putfig{./charts/pre_generated_charts/throughput_summary_per_library_summary.png}{
						Zestawienie agregowanych charakterystyk opisujących przepustowość, dla różnych bibliotek
					}{sumfig_3}
				}

				{
					\putfig{./charts/output_with_charts_as_images/throughput_per_library.png}{ Wykres przepustowości cząstkowej, dla \Delta t  = 1s}{sumfig_4}
				}
			}

			{
				\subsubsection{Analiza}

				Biblioteka \serek\  okazała się być najszybsza, przewyższając nieznacznie wynik osiągnięty przez implementację za pomocą \nonpl{jsoncpp}. Na wykresach numer \ref{sumfig_1} oraz \ref{sumfig_3}
				można zaobserwować, że biblioteka \serek\ w~każdej z~czterech statystyk dla zbioru wyników jest nieznacznie lepsza od pozostałych. Nieco więcej o~sukcesie tej biblioteki,
				można dowiedzieć się z~kolejnego wykresu (numer \ref{sumfig_2}), że jest to jednocześnie najwolniejsza biblioteka w~serializacji.
				Sukces więc nie jest bezwzględny, a~biblioteka zawdzięcza go błyskawicznej deserializacji. Mimo opisanego przygotowania i~próby zniwelowania wpływu
				czynników zewnętrznych nie udało się ich pozbyć całkowicie. Świadczy o~tym różnica pomiędzy czasem zmierzonym przez oprogramowanie \Jmeter, a~sumą czasów
				serializacji i~deserializacji zmierzonych przez serwer. Mimo, że dane wejściowe i~sposób ich dostarczenia do biblioteki były identyczne
				we wszystkich trzech przypadkach, czasy wynikające z~powyższej różnicy są różne i~wymykają się próbie ustalenia skąd one pochodzą. Kolejną wartą omówienia sprawą
				jest sromotna porażka biblioteki \nonpl{fc}. Mimo podjęcia kilku prób optymalizacji poprzez przeszukanie przykładów, dokumentacji
				oraz testów nie udało się osiągnąć poprawy czasu, szczególnie w~aspekcie deserializacji. Możliwe, że jest to nie dokończony element biblioteki, lub zostały popełnione
				błędy podczas implementacji.\n

				Biblioteka \nonpl{jsoncpp} jednakże wydaje się wygrywać w~kategorii, która nie była brana pod uwagę przy projektowaniu badania, jednakże zostanie
				ona wspomniana. Dokonując analizy wykresu numer \ref{sumfig_4}, można dostrzec, że przepustowość biblioteki \serek, znacząco się różni od pozostałych bibliotek.
				Żeby dokonać uściślenia tematu, tak prezentują się odchylenia standardowe:

				{
					\begin{itemize}
						\setlength\itemsep{-2mm}
						\item \serek: $0.697$
						\item \nonpl{fc}: $0.552$
						\item \nonpl{jsoncpp}: $0.509$
					\end{itemize}
				}

				Zarówno wykres jak i~policzone odchylenie standardowe wyraźnie wskazują, że najmniej stabilną biblioteką pod katem wydajności jest biblioteka \serek.
				Natomiast \nonpl{jsoncpp} zachowuje stabilne osiągi.
			}
		}

		{
			\section{Podsumowanie i~wnioski}

			Biblioteka oparta na pełnej automatycznej refleksji pól, która nie odbiega wydajnościowo od bieżących rozwiązań jest możliwa do napisania korzystając
			z~standardu C++ 20 w~2023 i~niniejsza praca jest na to dowodem. Osiągnięte wyniki są rezultatem pracy jednego programisty na przeciągu dwóch lat
			pracy, głównie skupionej dookoła prototypownia i~eksperymentowaniu. Dokonując analizy zmian (\ang{commit}) w~repozytorium\footnote{
				Analiza zmian w~repozytorium była możliwa dzięki zastosowaniu notacji \nonpl{gitmoji}\cite{gitmoji}, która wymusza na programiście dobrą praktykę
				ograniczania jednej zmiany (\ang{commit}), do bardzo małej porcji i~oznaczenie poprzez stosowną ikonę.
			} (rysunek numer \ref{commit}) wychodzi, że mniej niż $1\%$ wszystkich zmian (dokładnie $3$ zmiany) stanowiły optymalizacje wydajnościowe. Daje to pewien obraz,
			niedopracowania tej biblioteki, stawiając ją raczej jako dowód na działanie pomysłu (\ang{proof of concept}).\n

			\putfig{./charts/pre_generated_charts/commit_percentage.png}{Udział rodzajów zmian w~całym repozytorium \serek}{commit}

			\newpage

			Kolejnym problemem bibliotek tworzących tak spory dystans pomiędzy modelem danych a~punktem jego serializacji, jest zwiększenie poziomu trudności
			przy wytwarzaniu kodu, a~dokładnie przy analizie błędów. Niejednokrotnie wyjście z~kompilatora po znalezieniu błędu przekraczało kilka megabajtów,
			co zdecydowanie utrudnia znalezienie błędu. Sprawa mimo wszystko jest ułatwiona z~uwagi na wprowadzone koncepty w~języku C++, dzięki którym kompilator
			zdecydowanie precyzyjniej i~czytelniej dla programisty wskazuje niedoskonałości.\n

			Cała implementacja jest ciekawą odmianą dla obecnych rozwiązań i~zasługuje na większe zainteresowanie w~środowisku, ponieważ istnieje wiele przesłanek, że
			jest to rewolucja w~podejściu do programowania refleksyjnego w~języku C++. Trzeba również nadmienić, że serializacja do formatu \JSON w~przypadku tej biblioteki
			jest zaledwie wstępem do jej możliwości. Zapewniony mechanizm refleksji klas otwiera możliwości do tworzenia wizytatorów do obsługi typów takich jak \nonpl{YAML}, \nonpl{SQL}
			czy nawet \nonpl{XML}.
		}
	}

	% bibliography
	{
		\section{Bibliografia}
		\printbibliography[heading=none]
	}

	% list of captioned data
	{

		\section{Spis rysunków}
		\listofcaptioneds
		\thispagestyle{fancy}
	}

\end{document}
