\documentclass[12pt]{article}

% support for images
\usepackage{graphicx}

% font
\usepackage{tgheros}
\renewcommand*\familydefault{\sfdefault}
\usepackage[T1]{fontenc}


% justify
\usepackage{ragged2e}

% indents
\usepackage{indentfirst}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt}
\setlength{\JustifyingParindent}{1.25cm}
% source: https://tex.stackexchange.com/a/121230
\renewenvironment{justify}{%
	\trivlist
	\justifying
	\itemindent\JustifyingParindent
	\item\relax
	}{%
	\endtrivlist
}
\justifying

% fonts, margins, etc...
\usepackage{setspace}
\usepackage{authoraftertitle}
\usepackage{tikz}
\usepackage{anyfontsize}
\usetikzlibrary{positioning,calc}

% language
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[english,polish]{babel}

% bibliography
\usepackage{biblatex}
\addbibresource{../bibliography.bib}

% configure code fields
\usepackage{listings}
\lstdefinestyle{customcpp}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C++,
  showstringspaces=false,
  basicstyle=\fontsize{9pt}{9}\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  stringstyle=\color{orange},
}
\lstset{
	backgroundcolor=\color{white},
	language=C++,
	style=customcpp,
	tabsize=2
}

% set margins
\usepackage[
	a4paper,
	left=2.5cm,
	right=2.5cm,
	top=2.5cm,
	bottom=2.5cm,
	bindingoffset=1cm,
	headheight=1.25cm,
	footheight=1.35cm
]{geometry}

% configure header and footer (with page numbering)
\usepackage[lastpage,user]{zref}
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\fancyhf{}
\pagestyle{fancy}
\cfoot{\thepage\ z \zpageref{LastPage}}

% document info
\title{Implementacja i badanie wydajności serializacji wykonanej w paradygmacie meta-programowania względem standardowych rozwiązań w języku C++}
\author{inż. Krzysztof MOCHOCKI}
\date{}

% configure enumerator
\renewcommand{\labelenumi}{\arabic{enumi}.}
\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}.}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.}
\renewcommand{\labelenumiv}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.\arabic{enumiv}.}

% configure sections
\usepackage{titlesec}
\titleformat{\section}{\normalfont\Large\bfseries}{\thesection.}{1em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{\thesubsection.}{1em}{}
\titleformat{\subsubsection}{\normalfont\normalsize\bfseries}{\thesubsubsection.}{1em}{}

% function for disabling hyphenation
\newcommand{\disablewordwrap}{%
	\setlength{\hsize}{0.9\hsize}
	% \tolerance=1
	\hyphenpenalty=10000
	\hbadness=10000}

% configuration of table of contents
\usepackage{tocloft}
\setcounter{tocdepth}{2}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[hidelinks]{hyperref}

% add page break with new section
\newcommand{\sectionbreak}{\pagebreak}

% configure quotation
\usepackage{etoolbox}
\AtBeginEnvironment{quotation}{\itshape}

% configuration of figure captions
% source: https://tex.stackexchange.com/a/276796
\usepackage{caption}
\captionsetup[figure]{labelfont={bf}, labelformat={default}, labelsep=period, name={Wykres}}

% configure placing of figures in-text
% source: https://tex.stackexchange.com/a/8633
\usepackage{float}

% line spread
\linespread{1.5}

% aliases
\newcommand{\n}{\newline}

\begin{document}

	% make default captions disappear of list of tables and list of figures
	% to set custom, numbered mentioned in ToC
	\renewcommand*\listfigurename{}
	\renewcommand*\listoftables{}

	% tittle page
	\begin{titlepage}
		\clearpage
		\topskip0pt
		\centering

		\includegraphics[width=5cm, keepaspectratio=true]{./img/black_and_white_polsl_logo.png}

		{\LARGE\bfseries\ PRACA MAGISTERSKA}

		\vspace*{1cm}

		{\LARGE \MyTitle}

		\Large\bfseries\

		\begin{spacing}{1.125}
			\MyAuthor\

			000000000
			\vspace*{1cm}

			Kierunek: Informatyka Przemysłowa

			Specjalność: Inteligentne Systemy Przemysłowe

			\vspace*{1cm}

			PROMOTOR

			dr. inż. Adrian SMAGÓR

			\vspace*{0.5cm}

			KATEDRA Informatyki Przemysłowej

			Wydział Inżynierii Materiałowej

			\vspace*{\vfill}

			KATOWICE 2023
		\end{spacing}

		\thispagestyle{empty}
	\end{titlepage}

	% detail page
	{
		\disablewordwrap
		\large

		\vspace*{\vfill}

		{\bfseries\ Tytuł pracy:} \MyTitle

		\vspace*{\vfill}

		{\bfseries\ Streszczenie:} <tu będzie streszczenie>

		\vspace*{\vfill}

		{\bfseries\ Słowa kluczowe:} serializacja, deserializacja, C++, szablony, wydajność, meta-programowanie

		\vspace*{\vfill}

		{\bfseries\ Thesis title:} Implementation and performance testing of serialization performed in the meta-programming paradigm against standard solutions in the C++ language

		\vspace*{\vfill}

		{\bfseries\ Abstract:} <tu będzie streszczenie po angielskiemu>

		\vspace*{\vfill}

		{\bfseries\ Keywords:} serialization, deserialization, C++, templates, performance, meta-programming

		\vspace*{\vfill}

		\thispagestyle{empty}
		\newpage
	}

	% blank page
	{
		 \vspace*{\vfill}
		\thispagestyle{empty}
		\newpage
	}

	% table of contents
	{
		\tableofcontents
		\thispagestyle{fancy}
		\newpage
	}

	% introduction
	{
		\section{Wstęp}

		Serializacja w językach wysokiego poziomu, takich jak JavaScript czy Python jest, w przypadku standardowych formatów
		reprezentacji danych, echem przeszłości, ponieważ języki te posiadają natywne wsparcie do reprezentacji struktur danych
		zapewnione przez ichniejsze biblioteki standardowe.\n

		Niestety w momencie powstawania bieżącej pracy programiści języka C++ wciąż muszą uwzględniać problematykę
		serializacji podczas projektowania aplikacji oraz doboru bibliotek. Standard języka C++ w roku 2023 posiada szeroką
		paletę narzędzi do pisania szablonów klas i struktur, niestety nie posiada żadnych narzędzi do łatwego przeglądania
		struktur danych. Jest to oczywiście podyktowane względami wydajnościowymi oraz chęcią zachowania wstecznej
		kompatybilnością z językiem C. Istnieją rozszerzenia (na przykład reflexpr \cite*{cpp_extension_reflexpr_iso}), które
		umożliwiają iterowanie po elementach struktur danych, czy ich serializację, jednakże nie są one wciąż wdrożone do
		standardu \cite*{cpp_extension_reflexpr_short}.\n

		\begin{figure}[H]
			\centering
			\includegraphics{./charts/output_with_charts_as_images/json_vs_other_formats.png}
			\caption{Popularność haseł według strony Google \cite*{google_trends_json_api_vs_rest_of_the_world}}
			\medskip
		\end{figure}

		Niniejsza praca skupia się wyłącznie na formacie JSON \cite*{json_iso}, ponieważ jak można zauważyć na powyższym wykresie, jest on
		najbardziej powszechnym standardem komunikacji na świecie.\n

		Aktualnie możemy rozróżnić trzy podstawowe podejścia do tego problemu. Pierwsze, gdzie programista tylko wspomaga się
		zewnętrzną biblioteką, której jedynym zadaniem jest zapewnienie zgodności ze standardem formatu, zarówno podczas serializacji
		oraz deserializacji, natomiast nie zapewnia refleksji typów złożonych, których serializację bądź deserializację musi
		dokonać samodzielnie.\n

		Kolejnym podejściem do problemu jest rozwiązanie oparte na bibliotece, która również jak powyżej zawiera funkcję
		serializacji i deserializacji typów prostych, jednakże dodatkowo zawiera funkcję zewnętrznej refleksji typów,
		która najczęściej już na podstawie statycznych referencji do pola klasy, jest wstanie wydedukować typy i automatycznie
		poprowadzić proces serializacji lub deserializacji.\n

		Trzecim podejściem jest zastosowanie wewnętrznej refleksji. W innych językach najczęściej jest dostarczona przez język.
		Przykładowo w języku Python jest ona wyrażona w postaci pola {\it \_\_dict\_\_}, które dostarcza programiście całą klasę
		w postaci dynamicznej struktury danych typu klucz-wartość: słownika, gdzie kluczem jest nazwa pola klasy o typie
		łańcucha znakowego, natomiast wartością jest konkretna wartość w obecnej instancji klasy. Z punktu widzenia tematu
		niniejszej pracy, daje to pełny i prosty wgląd w strukturę zarówno klasy jak i hierarchii klas.
	}

	% theory
	{
		\section{Teoria}

		{
			\subsection{Definicja serializacji oraz deserializacji}

			Jak podaje portal {\it hazelcast.com}\cite{definitions_serial_and_deserial} definicja serializacji oraz deserializacji brzmi:

			\begin{quotation}
				{\bf Serialization} is the process of converting a data object - a combination of code
				and data represented within a region of data storage - into a series of bytes that
				saves the state of the object in an easily transmittable form. [\ldots]\n

				The reverse process - constructing a data structure or object from a series of
				bytes - is {\bf deserialization}. The deserialization process recreates the object,
				thus making the data easier to read and modify as a native structure in a programming language.
			\end{quotation}

			{\noindent Tłumacząc na język polski (tłumaczenie własne):}

			\begin{quotation}
				{\bf Serializacja} to proces konwersji obiektu danych - kombinacji kodu i danych
				reprezentowanych w regionie przechowywania danych - w serię bajtów zapisujących
				stan obiektu w łatwej do przesłania formie. [\ldots] \n

				Proces odwrotny - konstruowanie struktury danych lub obiektu z~szeregu
				bajtów - to {\bf deserializacja}. Proces deserializacji odtwarza obiekt,
				dzięki temu dane są łatwiejsze do odczytania i modyfikacji jako
				natywna struktura w języku programowania.
			\end{quotation}
		}

		{
			\newpage
			\subsection{Format JSON}

			Jest lekkim formatem danych wywodzącym się z języka JavaScript. Jak pokazano na wykresie numer jeden,
			JSON jest formatem o największej rozpoznawalności wśród tekstowych reprezentacji danych. Swój sukces
			zawdzięcza swojej formie: bardzo czytelnej dla człowieka, jednocześnie wydajnej dla komputerów zarówno
			podczas przetwarzania jak i generowania. Cecha ta sprawia, że praktycznie każdy współcześnie używany język
			programowania ma jego obsługę\cite{json_short} w~bibliotece standardowej lub posiada zastęp zewnętrznych
			bibliotek.\n

			Poddając JSON usystematyzowaniu, jest to format danych o strukturze drzewiastej, który technicznie
			może być zagnieżdżony w stopniu nieskończonym, w przeciwieństwie do formatów płaskich, takich jak CSV.\n
		}

		{
			\subsection{Definicja metaprogramowania}

			Opis, a zarazem definicja, czym metaprogramowanie jest zostało opisane niniejszym cytatem \cite{metaprogramming_definition}:

			\begin{quotation}
					In linguistics, a metalanguage is defined as follows [Dict]:\n

				“any language or symbolic system used to discuss, describe, or analyze another
					language or symbolic system”\n

					This definition characterizes the main idea of metaprogramming, which involves writing
				programs related by the meta-relationship, i.e. the relationship of “being about”. A program that
				manipulates another program is clearly an instance of metaprogramming. [\ldots]
			\end{quotation}

			\newpage
			{\noindent Tłumacząc na język polski (tłumaczenie własne):}

			\begin{quotation}
					W językoznawstwie metajęzyk definiuje się w następujący sposób [Słownik]:\n

				„dowolny język lub system symboliczny używany do omawiania, opisywania lub analizowania
					innego języka lub systemu symbolicznego”\n

					Ta definicja charakteryzuje główną ideę metaprogramowania, która obejmuje pisanie
				programów powiązanych meta-relacją, czyli relacją „bycia”. Program, który
				manipuluje innym programem jest ewidentnie przykładem metaprogramowania. [\ldots]
			\end{quotation}

			Paradygmat meta programowania w przypadku niniejszej pracy będzie można zaobserwować przy
			rozwiązaniach z zastosowaniem szablonów, a także nowinki językowej w języku C++: konceptów.
			Meta-relacja będzie się ujawniać, gdy kompilator (który w tym wypadku będzie wykonawcą meta języka),
			będzie wykonywał i generował automatycznie procedury refleksji typów, a także procedury ich serializacji
			oraz deserializacji.\n
		}

		{
			\newpage
			\subsection{Definicja programowania refleksyjnego}

			Definicję programowania zorientowanego na refleksję podaje Jonathan M. Sobel oraz Daniel P. Friedman
			w swoim materiale {\it An Introduction to Refection-Oriented Programming}\cite{reflection_definition},
			gdzie możemy przeczytać:

			\begin{quotation}
				[\ldots] reflective computational systems allow computations to observe and modify properties
				of their own behavior, especially properties that are typically observed only from some
				external, meta-level view point. [\ldots]
			\end{quotation}

			{\noindent Tłumacząc na język polski (tłumaczenie własne):}

			\begin{quotation}
				[\ldots] refleksyjne systemy obliczeniowe umożliwiają przetwarzanie poprzez obserwację i~modyfikację
				właściwości własnego zachowania, zwłaszcza właściwości, które zazwyczaj obserwuje się tylko z~zewnętrznego,
				meta-poziomowego punktu widzenia. [\ldots]
			\end{quotation}

			Dobrym przykładem programowania refleksyjnego, jest kompletna kontrola nad typami danych w języku Python,
			gdzie istnieje pełna możliwość dynamicznego przeglądania, dodawania, czy usuwania pól w klasie (lub wyłącznie w jednym obiekcie)
			podczas działania programu. Jest to na tyle rozbudowany obszar w~tym języku, że istnieją biblioteki takie jak
			{\it dataclasses}\cite{python_dataclass}, które podmieniają prostą definicję klasy z wyłącznie statycznymi polami,
			na definicję klasy z stworzonymi konstruktorami, reprezentacjami i zwykłymi polami, należącymi do obiektu.

			Warto nadmienić, że język C++ domyślnie nie posiada zbyt wielu mechanizmów ułatwiających programowanie refleksyjne,
			co jest przyczółkiem problematyki całej niniejszej pracy.
		}
	}

	% browse of current solutions
	{
		\section{Przegląd dostępnych rozwiązań}

		{
			\subsection{Manualna refleksja pól}

			Jest to najbardziej trywialne podejście do problemu, które zakłada samodzielną implementację całego przejścia
			po polach klasy. Biblioteka służy tylko jako interfejs do serializacji, jednakże nie zapewnia automatycznej
			zamiany typów złożonych, jedynie typów prostych. Przykładem takiej biblioteki jest {\it jsoncpp}\cite{jsoncpp_repo}.\n

			Cechą charakterystyczną takich bibliotek jest sposób zapisu funkcji, które są odpowiedzialne za serializację lub deserializację
			danej klasy, ponieważ są to najczęściej długie wielokrotnie zagnieżdżone funkcje, przekształcające po kolei wszystkie pola klasy.
			Opis ten od razu wskazuje na najważniejszą wadę tego podejścia. W przypadku zmiany struktury danych, na przykład poprzez usunięcie
			lub dodanie pola, wymagane jest ingerencja w kod w obu funkcjach.\n

			Redukcja członka klasy nie jest jeszcze problemem, ponieważ kompilator od razu poinformuje programistę o tym, że próbuje operować na polu,
			które (już) nie istnieje, jednakże w przypadku dodania pola, programista może nieświadomie dodać pole, które nie będzie podlegało serializacji
			lub deserializacji. Kolejne wada tego rozwiązania kryje się w mechanizmie konwersji typów, a mianowicie jeżeli typ danego pola zostanie
			zmieniony i przez przypadek istnieje niejawna, możliwa konwersja między starym, a nowym typem, serializacja oraz deserializacja może
			dyskretnie dokonywać błędnych operacji. Dobrym przykładem jest zmiana reprezentacji procentów z liczby całkowitej od 0 do 100,
			na typ zmiennoprzecinkowy od 0.0 do 1.0. Jeżeli podmienimy typ w klasie, ale nie podmienimy metody deserializacji, wszystkie wartości
			od 0\% do 99\% zostaną zaokrąglone do wartości całkowitej: 0. Istnieją mechanizmy pozwalające na uchronienie programisty przed takim
			czarnym scenariuszem, na przykład w postaci testów wzorcowych ({\it ang. pattern tests}), lub korzystanie w inteligentny sposób z szablonów,
			które mogłyby dedukować odpowiednią metodę obsługi pola, jednakże nie są one dostarczone od razu oraz nie wynikają z filozofii
			korzystania z tego typu bibliotek.\n

			Drugą stroną tego typu bibliotek jest, szczególnie dla młodych programistów, jest niski próg zrozumienia zasady działania
			biblioteki oraz jak należy ją używać. Inną zaletą jest duża wygoda w implementacji własnych, niecodziennych sposobów serializacji,
			które w przypadku dalszych rozwiązań nie jest takie oczywiste. Dobrym przykładem jest reprezentacja hasha\footnote{
				autor jest zdania, że nazwa {\it hash} nie powinna być spolszczona do słowa {\it hasz}, lub {\it skrót}\cite{hash_po_angielskiemu}
			}, od strony programu, najlepiej, żeby był reprezentowany binarnie, ponieważ zajmuje o wiele mniej miejsca oraz wygodnie się go przetwarza,
			natomiast z punktu widzenia warstwy transportowej, zdecydowanie lepszym zapisem jest forma łańcucha znaków, która jest łatwiejsza do porównania
			przez człowieka. Biblioteki z manualną refleksją typów bez problemu obsłużą tego typu momenty, ponieważ programista może bez problemu
			wywołać funkcję, która dokona odpowiedniej konwersji. Dalej omawiane rozwiązania niestety wymagają sprytnego przeładowywania funkcji, lub
			stosowania obiektów pośrednich.
		}

		{
			\subsection{Pół automatyczna refleksja pól}

			Podejście to wymaga biblioteki, która posiada odpowiednie funkcje lub makra, umożliwiające dokonanie pół automatycznej
			refleksji pól struktury danych. Po skorzystaniu z takiego zewnętrznego zasobu, programista nie ma bezpośredniego dostępu do samego momentu
			wpisania lub odczytu wartości z pól klasy. Jest to całkowicie ukryte przez bibliotekę, co ujawnia pierwszą trudność przy
			wykorzystaniu tego podejścia: trudność w ustawienia własnych metod serializacji, szczególnie, jeżeli biblioteka nie przewiduje
			takiego interfejsu. Natomiast, jeżeli nawet istnieje taka możliwość, to może ono doprowadzać do skomplikowania interfejsu, co
			zaś może doprowadzać do podwyższenia poziomu wejścia dla nowych programistów. Przykładem takiej biblioteki jest {\it fc}\cite{fc_repo}.\n

			Jednakże to podejście nie rozwiązuje w pełni również problemu przedstawionego w poprzednim podrozdziale, gdzie została wspomniana
			możliwość zmiany struktury klasy, na co nie zareaguje sam mechanizm serializacji z uwagi na istnienie
			konieczności manualnego wpisania jakie pola chcemy, żeby podlegały serializacji. Podejście z pół-automatyczną refleksją
			chroni programistę przed usunięciem pola, oraz zmianą typu pola, ponieważ sposób obsługi danego pola jest dedukowany przy
			kompilacji, za każdym razem. Jednakże wciąż istnieje możliwość dodania pola, a nie zostanie to zauważone, aż do pierwszych testów
			przez programistę. Można to próbować rozwiązać poprzez na przykład dodatkowe sprawdzanie wielkości klasy przy kompilacji.
		}

		{
			\subsection{W pełni automatyczna refleksja pól}

			Rozwiązanie koncepcyjnie, jest mocno zbliżone do poprzedniego, jednakże ma jedną podstawową różnicę, która rozwiązuje ostatni
			problem dotyczący dodania nowego pola w klasie. Jest to możliwe, ponieważ architektura oparta o taką bibliotekę, wymusza wplecenie
			interfejsu biblioteki w deklarację klasy i nie oczywiste jest dołożenie nowego pola bez skorzystania z narzuconego interfejsu, co
			radykalnie redukuje możliwość zaistnienia takiego problemu.\n

			W momencie powstawania tej pracy, nie ma informacji o istnieniu takich rozwiązań. Dlatego niniejsza praca ma na celu
			stworzenie takiego rozwiązania, a także zbadanie wydajności pod kątem czasu wykonania, względem wcześniej wspomnianych rozwiązań.
			
		}
	}

	\newpage

	{
		\begin{figure}[H]
			\centering
			\includegraphics[width=15cm,keepaspectratio=true]{./charts/output_with_charts_as_images/throughput_per_library.png}
			\caption{Wykres przepustowości cząstkowej, dla \Delta t  = 1s}
			\medskip
		\end{figure}
	}

	{
		\begin{figure}[H]
			\centering
			\includegraphics[width=15cm,keepaspectratio=true]{./charts/pre_generated_charts/throughput_summary_per_library_summary.png}
			\caption{Zestawienie zagregowanych charakterystyk opisujących przepustowość, dla różnych bibliotek}
			\medskip
		\end{figure}
	}

	{
		\begin{figure}[H]
			\centering
			\includegraphics[width=15cm,keepaspectratio=true]{./charts/pre_generated_charts/total_request_time_per_library_summary.png}
			\caption{Zestawienie zagregowanych charakterystyk opisujących całkowity czas wykonania zapytania, dla różnych bibliotek}
			\medskip
		\end{figure}
	}

	% \subsection{Pod Wstęp}
	% \subsubsection{Pod Pod Wstęp}

	% \begin{enumerate}
	% 	\item One
	% 	\item Two
	% 	\item Three
	% 	\begin{enumerate}
	% 		\item Three point one
	% 		\begin{enumerate}
	% 		\item Three point one, point one
	% 			\begin{enumerate}
	% 			\item Three point one, point one, point one 1234567890
	% 			\item Three point one, point one, point two
	% 			\end{enumerate}
	% 		\end{enumerate}
	% 	\end{enumerate}
	% 	\item Four
	% 	\item Five
	% 	\end{enumerate}

	% bibliography
	{
		\newpage
		\section{Bibliografia}
		\printbibliography[heading=none]
	}

	% list of tables
	{
		\newpage
		\section{Spis Tabel}
		\listoftables
		\thispagestyle{fancy}
		\newpage
	}

	% list of figures
	{
		\newpage
		\section{Spis Wykresów}
		\listoffigures
		\thispagestyle{fancy}
		\newpage
	}

\end{document}
