\documentclass[12pt]{article}

% support for images
\usepackage{graphicx}

% font
\usepackage{tgheros}
\renewcommand*\familydefault{\sfdefault}
\usepackage[T1]{fontenc}


% justify
\usepackage{ragged2e}

% indents
\usepackage{indentfirst}
\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt}
\setlength{\JustifyingParindent}{1.25cm}
% source: https://tex.stackexchange.com/a/121230
\renewenvironment{justify}{%
	\trivlist
	\justifying
	\itemindent\JustifyingParindent
	\item\relax
	}{%
	\endtrivlist
}
\justifying

% fonts, margins, etc...
\usepackage{setspace}
\usepackage{authoraftertitle}
\usepackage{tikz}
\usepackage{anyfontsize}
\usetikzlibrary{positioning,calc}

% language
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[english,polish]{babel}

% bibliography
\usepackage{biblatex}
\addbibresource{../bibliography.bib}

% configure code fields
\usepackage{listings}
\lstdefinestyle{customcpp}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C++,
  showstringspaces=false,
  basicstyle=\fontsize{9pt}{9}\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  stringstyle=\color{orange},
}
\lstset{
	backgroundcolor=\color{white},
	language=C++,
	style=customcpp,
	tabsize=2
}

% set margins
\usepackage[
	a4paper,
	left=2.5cm,
	right=2.5cm,
	top=2.5cm,
	bottom=2.5cm,
	bindingoffset=1cm,
	headheight=1.25cm,
	footheight=1.35cm
]{geometry}

% configure header and footer (with page numbering)
\usepackage[lastpage,user]{zref}
\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\fancyhf{}
\pagestyle{fancy}
\cfoot{\thepage\ z \zpageref{LastPage}}

% document info
\title{Implementacja i badanie wydajności serializacji wykonanej w paradygmacie meta-programowania względem standardowych rozwiązań w języku C++}
\author{inż. Krzysztof MOCHOCKI}
\date{}

% configure enumerator
\renewcommand{\labelenumi}{\arabic{enumi}.}
\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}.}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.}
\renewcommand{\labelenumiv}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.\arabic{enumiv}.}

% configure sections
\usepackage{titlesec}
\titleformat{\section}{\normalfont\Large\bfseries}{\thesection.}{1em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{\thesubsection.}{1em}{}
\titleformat{\subsubsection}{\normalfont\normalsize\bfseries}{\thesubsubsection.}{1em}{}

% function for disabling hyphenation
\newcommand{\disablewordwrap}{%
	\setlength{\hsize}{0.9\hsize}
	% \tolerance=1
	\hyphenpenalty=10000
	\hbadness=10000}

% configuration of table of contents
\usepackage{tocloft}
\setcounter{tocdepth}{2}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage[hidelinks]{hyperref}

% add page break with new section
\newcommand{\sectionbreak}{\pagebreak}

% configure quotation
\usepackage{etoolbox}
\AtBeginEnvironment{quotation}{\itshape}

% configuration of figure captions
% source: https://tex.stackexchange.com/a/276796
\usepackage{caption}
\captionsetup[figure]{labelfont={bf}, labelformat={default}, labelsep=period, name={Wykres}}

% configure placing of figures in-text
% source: https://tex.stackexchange.com/a/8633
\usepackage{float}

% line spread
\linespread{1.5}

% aliases
\newcommand{\n}{\newline}

\begin{document}

	% make default captions disappear of list of tables and list of figures
	% to set custom, numbered mentioned in ToC
	\renewcommand*\listfigurename{}
	\renewcommand*\listoftables{}

	% tittle page
	\begin{titlepage}
		\clearpage
		\topskip0pt
		\centering

		\includegraphics[width=5cm, keepaspectratio=true]{./img/black_and_white_polsl_logo.png}

		{\LARGE\bfseries\ PRACA MAGISTERSKA}

		\vspace*{1cm}

		{\LARGE \MyTitle}

		\Large\bfseries\

		\begin{spacing}{1.125}
			\MyAuthor\

			000000000
			\vspace*{1cm}

			Kierunek: Informatyka Przemysłowa

			Specjalność: Inteligentne Systemy Przemysłowe

			\vspace*{1cm}

			PROMOTOR

			dr. inż. Adrian SMAGÓR

			\vspace*{0.5cm}

			KATEDRA Informatyki Przemysłowej

			Wydział Inżynierii Materiałowej

			\vspace*{\vfill}

			KATOWICE 2023
		\end{spacing}

		\thispagestyle{empty}
	\end{titlepage}

	% detail page
	{
		\disablewordwrap
		\large

		\vspace*{\vfill}

		{\bfseries\ Tytuł pracy:} \MyTitle

		\vspace*{\vfill}

		{\bfseries\ Streszczenie:} <tu będzie streszczenie>

		\vspace*{\vfill}

		{\bfseries\ Słowa kluczowe:} serializacja, deserializacja, C++, szablony, wydajność, meta-programowanie

		\vspace*{\vfill}

		{\bfseries\ Thesis title:} Implementation and performance testing of serialization performed in the meta-programming paradigm against standard solutions in the C++ language

		\vspace*{\vfill}

		{\bfseries\ Abstract:} <tu będzie streszczenie po angielskiemu>

		\vspace*{\vfill}

		{\bfseries\ Keywords:} serialization, deserialization, C++, templates, performance, meta-programming

		\vspace*{\vfill}

		\thispagestyle{empty}
		\newpage
	}

	% blank page
	{
		 \vspace*{\vfill}
		\thispagestyle{empty}
		\newpage
	}

	% table of contents
	{
		\tableofcontents
		\thispagestyle{fancy}
		\newpage
	}

	% introduction
	{
		\section{Wstęp}

		Serializacja w językach wysokiego poziomu, takich jak JavaScript czy Python jest, w przypadku standardowych formatów
		reprezentacji danych, echem przeszłości, ponieważ języki te posiadają natywne wsparcie do reprezentacji struktur danych
		zapewnione przez ichniejsze biblioteki standardowe.\n

		Niestety w momencie powstawania bieżącej pracy programiści języka C++ wciąż muszą uwzględniać problematykę
		serializacji podczas projektowania aplikacji oraz doboru bibliotek. Standard języka C++ w roku 2023 posiada szeroką
		paletę narzędzi do pisania szablonów klas i struktur, niestety nie posiada żadnych narzędzi do łatwego przeglądania
		struktur danych. Jest to oczywiście podyktowane względami wydajnościowymi oraz chęcią zachowania wstecznej
		kompatybilnością z językiem C. Istnieją rozszerzenia (na przykład reflexpr \cite*{cpp_extension_reflexpr_iso}), które
		umożliwiają iterowanie po elementach struktur danych, czy ich serializację, jednakże nie są one wciąż wdrożone do
		standardu \cite*{cpp_extension_reflexpr_short}.\n

		\begin{figure}[H]
			\centering
			\includegraphics{./charts/output_with_charts_as_images/json_vs_other_formats.png}
			\caption{Popularność haseł według strony Google \cite*{google_trends_json_api_vs_rest_of_the_world}}
			\medskip
		\end{figure}

		Niniejsza praca skupia się wyłącznie na formacie JSON \cite*{json_iso}, ponieważ jak można zauważyć na powyższym wykresie, jest on
		najbardziej powszechnym standardem komunikacji na świecie.\n

		Aktualnie możemy rozróżnić trzy podstawowe podejścia do tego problemu. Pierwsze, gdzie programista tylko wspomaga się
		zewnętrzną biblioteką, której jedynym zadaniem jest zapewnienie zgodności ze standardem formatu, zarówno podczas serializacji
		oraz deserializacji, natomiast nie zapewnia refleksji typów złożonych, których serializację bądź deserializację musi
		dokonać samodzielnie.\n

		Kolejnym podejściem do problemu jest rozwiązanie oparte na bibliotece, która również jak powyżej zawiera funkcję
		serializacji i deserializacji typów prostych, jednakże dodatkowo zawiera funkcję zewnętrznej refleksji typów,
		która najczęściej już na podstawie statycznych referencji do pola klasy, jest wstanie wydedukować typy i automatycznie
		poprowadzić proces serializacji lub deserializacji.\n

		Trzecim podejściem jest zastosowanie wewnętrznej refleksji. W innych językach najczęściej jest dostarczona przez język.
		Przykładowo w języku Python jest ona wyrażona w postaci pola {\it \_\_dict\_\_}, które dostarcza programiście całą klasę
		w postaci dynamicznej struktury danych typu klucz-wartość: słownika, gdzie kluczem jest nazwa pola klasy o typie
		łańcucha znakowego, natomiast wartością jest konkretna wartość w obecnej instancji klasy. Z punktu widzenia tematu
		niniejszej pracy, daje to pełny i prosty wgląd w strukturę zarówno klasy jak i hierarchii klas.
	}

	% theory
	{
		\section{Teoria}

		{
			\subsection{Definicja serializacji oraz deserializacji}

			Jak podaje portal {\it hazelcast.com}\cite{definitions_serial_and_deserial} definicja serializacji oraz deserializacji brzmi:

			\begin{quotation}
				{\bf Serialization} is the process of converting a data object - a combination of code
				and data represented within a region of data storage - into a series of bytes that
				saves the state of the object in an easily transmittable form. [\ldots]\n

				The reverse process - constructing a data structure or object from a series of
				bytes - is {\bf deserialization}. The deserialization process recreates the object,
				thus making the data easier to read and modify as a native structure in a programming language.
			\end{quotation}

			{\noindent Tłumacząc na język polski (tłumaczenie własne):}

			\begin{quotation}
				{\bf Serializacja} to proces konwersji obiektu danych - kombinacji kodu i danych
				reprezentowanych w regionie przechowywania danych - w serię bajtów zapisujących
				stan obiektu w łatwej do przesłania formie. [\ldots] \n

				Proces odwrotny - konstruowanie struktury danych lub obiektu z~szeregu
				bajtów - to {\bf deserializacja}. Proces deserializacji odtwarza obiekt,
				dzięki temu dane są łatwiejsze do odczytania i modyfikacji jako
				natywna struktura w języku programowania.
			\end{quotation}
		}

		{
			\newpage
			\subsection{Format JSON}

			Jest lekkim formatem danych wywodzącym się z języka JavaScript. Jak pokazano na wykresie numer jeden,
			JSON jest formatem o największej rozpoznawalności wśród tekstowych reprezentacji danych. Swój sukces
			zawdzięcza swojej formie: bardzo czytelnej dla człowieka, jednocześnie wydajnej dla komputerów zarówno
			podczas przetwarzania jak i generowania. Cecha ta sprawia, że praktycznie każdy współcześnie używany język
			programowania ma jego obsługę\cite{json_short} w~bibliotece standardowej lub posiada zastęp zewnętrznych
			bibliotek.\n

			Poddając JSON usystematyzowaniu, jest to format danych o strukturze drzewiastej, który technicznie
			może być zagnieżdżony w stopniu nieskończonym, w przeciwieństwie do formatów płaskich, takich jak CSV.\n
		}

		{
			\subsection{Definicja metaprogramowania}

			Opis, a zarazem definicja, czym metaprogramowanie jest zostało opisane niniejszym cytatem \cite{metaprogramming_definition}:

			\begin{quotation}
					In linguistics, a metalanguage is defined as follows [Dict]:\n

				“any language or symbolic system used to discuss, describe, or analyze another
					language or symbolic system”\n

					This definition characterizes the main idea of metaprogramming, which involves writing
				programs related by the meta-relationship, i.e. the relationship of “being about”. A program that
				manipulates another program is clearly an instance of metaprogramming. [\ldots]
			\end{quotation}

			\newpage
			{\noindent Tłumacząc na język polski (tłumaczenie własne):}

			\begin{quotation}
					W językoznawstwie metajęzyk definiuje się w następujący sposób [Słownik]:\n

				„dowolny język lub system symboliczny używany do omawiania, opisywania lub analizowania
					innego języka lub systemu symbolicznego”\n

					Ta definicja charakteryzuje główną ideę metaprogramowania, która obejmuje pisanie
				programów powiązanych meta-relacją, czyli relacją „bycia”. Program, który
				manipuluje innym programem jest ewidentnie przykładem metaprogramowania. [\ldots]
			\end{quotation}

			Paradygmat meta programowania w przypadku niniejszej pracy będzie można zaobserwować przy
			rozwiązaniach z zastosowaniem szablonów, a także nowinki językowej w języku C++: konceptów.
			Meta-relacja będzie się ujawniać, gdy kompilator (który w tym wypadku będzie wykonawcą meta języka),
			będzie wykonywał i generował automatycznie procedury refleksji typów, a także procedury ich serializacji
			oraz deserializacji.\n
		}

		{
			\newpage
			\subsection{Definicja programowania refleksyjnego}

			Definicję programowania zorientowanego na refleksję podaje Jonathan M. Sobel oraz Daniel P. Friedman
			w swoim materiale {\it An Introduction to Refection-Oriented Programming}\cite{reflection_definition},
			gdzie możemy przeczytać:

			\begin{quotation}
				[\ldots] reflective computational systems allow computations to observe and modify properties
				of their own behavior, especially properties that are typically observed only from some
				external, meta-level view point. [\ldots]
			\end{quotation}

			{\noindent Tłumacząc na język polski (tłumaczenie własne):}

			\begin{quotation}
				[\ldots] refleksyjne systemy obliczeniowe umożliwiają przetwarzanie poprzez obserwację i~modyfikację
				właściwości własnego zachowania, zwłaszcza właściwości, które zazwyczaj obserwuje się tylko z~zewnętrznego,
				meta-poziomowego punktu widzenia. [\ldots]
			\end{quotation}

			Dobrym przykładem programowania refleksyjnego, jest kompletna kontrola nad typami danych w języku Python,
			gdzie istnieje pełna możliwość dynamicznego przeglądania, dodawania, czy usuwania pól w klasie (lub wyłącznie w jednym obiekcie)
			podczas działania programu. Jest to na tyle rozbudowany obszar w~tym języku, że istnieją biblioteki takie jak
			{\it dataclasses}\cite{python_dataclass}, które podmieniają prostą definicję klasy z wyłącznie statycznymi polami,
			na definicję klasy z stworzonymi konstruktorami, reprezentacjami i zwykłymi polami, należącymi do obiektu.

			Warto nadmienić, że język C++ domyślnie nie posiada zbyt wielu mechanizmów ułatwiających programowanie refleksyjne,
			co jest przyczółkiem problematyki całej niniejszej pracy.
		}
	}

	% browse of current solutions
	{
		\section{Przegląd dostępnych rozwiązań}

		{
			\subsection{Manualna refleksja pól}

			Jest to najbardziej trywialne podejście do problemu, które zakłada samodzielną implementację całego przejścia
			po polach klasy. Biblioteka służy tylko jako interfejs do serializacji, jednakże nie zapewnia automatycznej
			zamiany typów złożonych, jedynie typów prostych. Przykładem takiej biblioteki jest {\it jsoncpp}\cite{jsoncpp_repo}.\n

			{
				\subsubsection{Wady i zalety}

				Cechą charakterystyczną takich bibliotek jest sposób zapisu funkcji, które są odpowiedzialne za serializację lub deserializację
				danej klasy, ponieważ są to najczęściej długie wielokrotnie zagnieżdżone funkcje, przekształcające po kolei wszystkie pola klasy.
				Opis ten od razu wskazuje na najważniejszą wadę tego podejścia. W przypadku zmiany struktury danych, na przykład poprzez usunięcie
				lub dodanie pola, wymagane jest ingerencja w kod w obu funkcjach.\n

				Redukcja członka klasy nie jest jeszcze problemem, ponieważ kompilator od razu poinformuje programistę o tym, że próbuje operować na polu,
				które (już) nie istnieje, jednakże w przypadku dodania pola, programista może nieświadomie dodać pole, które nie będzie podlegało serializacji
				lub deserializacji. Kolejne wada tego rozwiązania kryje się w mechanizmie konwersji typów, a mianowicie jeżeli typ danego pola zostanie
				zmieniony i przez przypadek istnieje niejawna, możliwa konwersja między starym, a nowym typem, serializacja oraz deserializacja może
				dyskretnie dokonywać błędnych operacji. Dobrym przykładem jest zmiana reprezentacji procentów z liczby całkowitej od 0 do 100,
				na typ zmiennoprzecinkowy od 0.0 do 1.0. Jeżeli podmienimy typ w klasie, ale nie podmienimy metody deserializacji, wszystkie wartości
				od 0\% do 99\% zostaną zaokrąglone do wartości całkowitej: 0. Istnieją mechanizmy pozwalające na uchronienie programisty przed takim
				czarnym scenariuszem, na przykład w postaci testów wzorcowych ({\it ang. pattern tests}), lub korzystanie w inteligentny sposób z szablonów,
				które mogłyby dedukować odpowiednią metodę obsługi pola, jednakże nie są one dostarczone od razu oraz nie wynikają z filozofii
				korzystania z tego typu bibliotek.\n

				Drugą stroną tego typu bibliotek jest, szczególnie dla młodych programistów, jest niski próg zrozumienia zasady działania
				biblioteki oraz jak należy ją używać. Inną zaletą jest duża wygoda w implementacji własnych, niecodziennych sposobów serializacji,
				które w przypadku dalszych rozwiązań nie jest takie oczywiste. Dobrym przykładem jest reprezentacja hasha\footnote{
					autor jest zdania, że nazwa {\it hash} nie powinna być spolszczona do słowa {\it hasz}, lub {\it skrót}\cite{hash_po_angielskiemu}
				}, od strony programu, najlepiej, żeby był reprezentowany binarnie, ponieważ zajmuje o wiele mniej miejsca oraz wygodnie się go przetwarza,
				natomiast z punktu widzenia warstwy transportowej, zdecydowanie lepszym zapisem jest forma łańcucha znaków, która jest łatwiejsza do porównania
				przez człowieka. Biblioteki z manualną refleksją typów bez problemu obsłużą tego typu momenty, ponieważ programista może bez problemu
				wywołać funkcję, która dokona odpowiedniej konwersji. Dalej omawiane rozwiązania niestety wymagają sprytnego przeładowywania funkcji, lub
				stosowania obiektów pośrednich.
			}

			{
				\subsubsection{Przykład użycia}

				\begin{lstlisting}[frame=single]
class MyClass
{
	bool field_0;
	int field_1;
	std::string field_2;
	std::vector<int> field_3;
};

std::string serialize_my_class(const MyClass& obj)
{
	lib::json json{};
	json["field_0"] = lib::json::to_json_bool(obj.field_0);
	json["field_1"] = lib::json::to_json_int(obj.field_1);
	json["field_2"] = lib::json::to_json_string(obj.field_2);
	json["field_3"] = lib::json::json_array();
	json["field_3"].reserve(obj.field_3.size());
	for(const int var : obj.field_3)
		json["field_3"].append(var);
	return json.to_string();
}

MyClass deserialize_my_class(const std::string& json_text)
{
	lib::json json = lib::json::parse_from_string(json_text);
	MyClass result{};
	result.field_0 = assert_is_field_exist_and_return("field_0").as_bool();
	result.field_1 = assert_is_field_exist_and_return("field_1").as_int();
	result.field_2 = assert_is_field_exist_and_return("field_2").as_string();
	const auto json_array = assert_is_field_exist_and_return("field_3").as_array();
	result.field_3.reserve(json_array.size());
	for(const auto& json_element : json_array)
		result.field_3.emplace_back(json_element.as_int());
	return result;
}
				\end{lstlisting}
			}
		}

		{
			\subsection{Pół automatyczna refleksja pól}

			Podejście to wymaga biblioteki, która posiada odpowiednie funkcje lub makra, umożliwiające dokonanie pół automatycznej
			refleksji pól struktury danych. Po skorzystaniu z takiego zewnętrznego zasobu, programista nie ma bezpośredniego dostępu do samego momentu
			wpisania lub odczytu wartości z pól klasy. Przykładem takiej biblioteki jest {\it fc}\cite{fc_repo}.\n

			{
				\subsubsection{Wady i zalety}

				Fakt ukrycia tego mechanizmu przez bibliotekę, ujawnia pierwszą trudność przy wykorzystaniu tego podejścia: trudność w ustawienia własnych
				metod serializacji, szczególnie, jeżeli biblioteka nie przewiduje takiego interfejsu. Natomiast, jeżeli nawet istnieje taka możliwość,
				to może ono doprowadzać do skomplikowania interfejsu, co zaś może doprowadzać do podwyższenia poziomu wejścia dla nowych programistów.

				Jednakże to podejście nie rozwiązuje w pełni również problemu przedstawionego w poprzednim podrozdziale, gdzie została wspomniana
				możliwość zmiany struktury klasy, na co nie zareaguje sam mechanizm serializacji z uwagi na istnienie
				konieczności manualnego wpisania jakie pola chcemy, żeby podlegały serializacji. Podejście z pół-automatyczną refleksją
				chroni programistę przed usunięciem pola, oraz zmianą typu pola, ponieważ sposób obsługi danego pola jest dedukowany przy
				kompilacji, za każdym razem. Jednakże wciąż istnieje możliwość dodania pola, a nie zostanie to zauważone, aż do pierwszych testów
				przez programistę. Można to próbować rozwiązać poprzez na przykład dodatkowe sprawdzanie wielkości klasy przy kompilacji.
			}

			{
				\subsubsection{Przykład użycia}
				\begin{lstlisting}[frame=single]
// MyClass.hpp
class MyClass
{
	bool field_0;
	int field_1;
	std::string field_2;
	std::vector<int> field_3;
};

LIB_REFLECTOR(MyClass, (field_0)(field_1)(field_2)(field_3));

// MyClass.cpp
std::string serialize_my_class(const MyClass& obj)
{
	return lib::json::to_json(obj).to_string();
}

MyClass deserialize_my_class(const std::string& json_text)
{
	return lib::json::from_string(json_text).as<MyClass>();
}
				\end{lstlisting}
			}
		}

		{
			\subsection{W pełni automatyczna refleksja pól}

			Rozwiązanie koncepcyjnie, jest mocno zbliżone do poprzedniego, jednakże ma jedną podstawową różnicę, która rozwiązuje ostatni
			problem dotyczący dodania nowego pola w klasie. Jest to możliwe, ponieważ architektura oparta o taką bibliotekę, wymusza wplecenie
			interfejsu biblioteki w deklarację klasy i nie oczywiste jest dołożenie nowego pola bez skorzystania z narzuconego interfejsu, co
			radykalnie redukuje możliwość zaistnienia takiego problemu.\n

			W momencie powstawania tej pracy, autor nie ma informacji o istnieniu takich rozwiązań. Dlatego niniejsza praca ma na celu
			stworzenie takiego rozwiązania, a także zbadanie wydajności pod kątem czasu wykonania, względem wcześniej wspomnianych rozwiązań.
		}
	}

	{
		\section{Implementacja biblioteki {\it serek}}

		{
			\subsection{Dobór technologii}

			{
				\subsubsection{System budowy oraz środowisko deweloperskie}

				Celem zapewnienia systemu budowy, który jest przystosowany do użycia na wielu platformach, oraz udostępnia narzędzia pozwalające na prostą
				integracje z innymi bibliotekami, wybór {\it cmake}'a\cite{cmake_docs} jest domyślnym wyborem w przypadku tej biblioteki, jak i wielu innych.\n

				Jedną z głównych zalet tego oprogramowania, jest możliwość rozproszonego definiowania celów budowy. Dzięki takiemu podejściu nie jest tworzony
				jeden wielki plik z definicją całego projektu, tylko wiele plików, które skupiają się na konfiguracji poszczególnych elementów aplikacji.\n

				Dodatkowo istnieje możliwość tworzenia własnych, niekompilowanych (innych niż pliki wykonywalne, czy biblioteki) celów budowy. Zostało to zagospodarowane
				przez integrację z różnymi narzędziami wspomagającymi rozwój oprogramowania. Pierwszym z nich jest system kontroli wersji {\it git}\cite{git_docs}. Oprócz standardowego
				zastosowania podczas wytwarzanie oprogramowania, został też zintegrowany podczas budowy oprogramowania, automatycznie pobierając wszystkie pakiety zależne
				({\it ang. submodules}), dzięki czemu podczas budowy, wszystkie paczki są zaktualizowane.\n

				Kolejnym miejscem jest dodanie statycznej analizy kodu za pomocą programu {\it cppcheck}\cite{cppcheck_repo}, który pomógł znaleźć masę drobnych błędów,
				jak nie zainicjalizowane zmienne, czy funkcje nie zwracające żadnej wartości, mimo takiej deklaracji. Dodatkowo udało się wyeliminować kilka funkcji,
				które jak się okazało były martwym kodem nie wołanym w żadnym możliwym przejściu.\n

				Następnym oprogramowaniem, które zostało zintegrowane z systemem budowy, to formater kodu {\it clang-format}\cite{clangformat_docs}, dzięki czemu
				udało się trzymać jednolity format kodu. Oprócz samych względów estetycznych, sma formater potrafi pomóc w znajdywaniu prostych błędów, polegających
				na braku klamry, czy średnika, ponieważ w okolicy literówki, najczęściej formatowanie jest wyraźnie inne i przykuwa to wzrok podczas poszukiwań.\n

				Ostatnim zintegrowanym narzędziem deweloperskim jest automatyczne generowanie interaktywnej dokumentacji w formie gotowej strony www. Poniżej zrzuty
				ekranu prezentujące wygląd wygenerowanej dokumentacji.\n

				\begin{figure}[H]
					\centering
					\includegraphics[width=15cm,keepaspectratio=true]{./img/documentation_part_1.png}
					\caption*{Widok na automatycznej dokumentacji na spis wszystkich przestrzeni nazw w projekcie wraz z krótkim opisem}
					\medskip
				\end{figure}

				\begin{figure}[H]
					\centering
					\includegraphics[width=15cm,keepaspectratio=true]{./img/documentation_part_2.png}
					\caption*{Widok automatycznej dokumentacji na opis funkcji}
					\medskip
				\end{figure}

				\newpage

				Całość opiera się o narzędzie {\it Doxygen}\cite{doxygen_docs}, które za pomocą specjalnych komentarzy w kodzie,
				jest w stanie wygenerować różnego rodzaju dokumentację.\n

				\begin{lstlisting}[frame=single]
/**
* @brief overload of above, allows additionally print given values
*
* @tparam operator_t functor that will be used for comparison @see @link https://en.cppreference.com/w/cpp/utility/functional/less @endlink
* @tparam T type of compared elements
* @param l_value left operand
* @param r_value right operand
* @param error_message message to forward to exception
*/
template<template<typename T> typename operator_t, typename T>
void require(const T& l_value, const T& r_value, const str_v error_message = "comparison failed!")
{/* implementation */}

/**
* @brief overload of above, specialized for checking pointers
*
* @tparam pointer_t type of pointer to validate
* @param ptr pointer to check
* @param error_message message to forward to exception
*/
template<reqs::comparable_as_pointer_req pointer_t>
void require(const pointer_t& ptr, const str_v error_message = "given pointer was null!")
{/* implementation */}
				\end{lstlisting}
			}
		}

		{
			\subsection{Problematyka i wyzwania podczas implementacji}

			Problematyka całego podejścia jest dwuwymiarowa, ponieważ istnieje konieczność stworzenia interfejsu biblioteki, która wykluczy, lub znacząco
			zredukuje możliwość wystąpienia wcześniej wspomnianych problemów. Dodatkowo należy przewidzieć możliwość zadawania własnych metod serializacji,
			najlepiej w jednolity sposób. Poza tymi wymaganiami, został sformułowany jeszcze jeden warunek dla całej implementacji: brak korzystania z makr.\n

			Jak zostało wspomniane w rozdziale poświęconym omówieniu definicji refleksji, język C++ nie posiada zbyt dużego wsparcia dla programowania
			refleksyjnego. Będzie to wyzwanie ściśle techniczne, a dokładnie implementacyjne. Rozwiązanie tego problemu daje bardzo wymierne korzyści,
			ponieważ otwiera to drzwi do całej gamy rozwiązań z serializacji, nie tylko w formacie {\it JSON}, ale także do takich formatów jak SQL, czy
			postać binarna.\n

			Intuicyjnym podejściem wydaje się wykorzystanie wzorca ciekawie powtarzającego się wzoru szablonu\footnote{
				CRTP ({\it ang. curiously recurring template pattern}) - wzorzec projektowy polegający na przekazaniu klasie rodzica, typu klasy dziecka\cite{crtp_definition}
			}, które umożliwiałoby potencjalnie abstrakcję niezbędnych narzędzi do przejścia po polach klasy dziecka u rodzica. To podejście niestety jest skazane na
			porażkę. Jest to spowodowane miejscem korzystania z~tego wzorca, a mianowice, przy samej deklaracji klasy, co jest zbyt wczesnym etapem, gdy pola nie są
			jeszcze zdefiniowane. Dodatkowo to rozwiązanie, gdzie wszystkie pola byłyby wymienione jako referencje u rodzica ma jeszcze jedną, jak zresztą każde
			inne rozwiązanie opierające się na wymienieniu w sekwencji wszystkich pól, wadę: nie eliminuje wciąż problemu gapiostwa programisty, który mógłby zapomnieć
			dopisać nowe pole w strukturze danych, dlatego zaszła konieczność wplecenia interfejsu pomiędzy deklaracje pól klasy.
		}

		{
			\subsection{Architektura}

			Rozwiązaniem bolączek wspomnianych w poprzednim rozdziale jest zastosowanie autorskiego rozwiązania: statycznej listy jednokierunkowe, na podstawie
			referencji do pól klasy. Podejście to wykorzystuje fakt, że dostęp do referencji do pole numer jeden uzyskujemy w momencie postawienia średnika przy jego deklaracji.
			Dlatego najwcześniej gdy się da do takiego pola odwołać, jest deklaracja następnego pola, lub zewnętrze klasy, które również zostanie tutaj zagospodarowane,
			ale nieco inaczej niż we wcześniej wspomnianej pół automatycznej refleksji typów. Jeżeli więc pociągnąć ten koncept dalej, gdzie pole drugie wskazuje, na
			pole pierwsze, a pole trzecie na drugie i tak dalej, otrzymujemy formalnie rzecz ujmując listę jednokierunkową, której zakończeniem jest pierwszy członek
			klasy. Rozwiązanie to już koncepcyjnie rozwiązuje największą bolączkę poprzednich rozwiązań: oderwanie miejsca refleksji od bieżącego stanu klasy.
			Teraz każde pole przy deklaracji wskazuje na poprzednie, jest więc to rzucające się w oczy, przy dodawaniu lub usuwaniu pól klasy, nie do pominięcia.\n

			Jednakże rozwiązanie jednego problemu nasuwa kolejne. Pierwszym jest rozwiązanie problemu dostępu do właściwych typów pod kolejnymi polami, a także
			miejscem na przechowywanie tej referencji, która mogłaby sprawić, że cała klasa przytyje w zależności od środowiska o $N * 8$, lub $N * 4$ bajty,
			gdzie N jest liczbą pól. Dodatkowo, wciąż jest problem z początkiem listy, czyli referencją na ostatnie pole klasy. O ile koniec jest oczywisty,
			w postaci pierwszego pola, to początek już nie i wymaga osobnego zainteresowania. Kolejnym kłopotem jest miejsce pobrania nazwy pola, co jest
			konieczne, aby móc zbudować obiekt {\it JSON}, gdzie w wcześniej prezentowanych rozwiązaniach użytkownik sam deklarował nazwę pola, lub nazwa ta
			była w prosty sposób wyłuskiwana przez makro.\n

			{
				\subsubsection{Problem dostępu do wartości pola}

				Rozwiązania są co najmniej dwa. Pierwszym, które nie zostało wybrane, to skorzystanie z interfejsu jakie oferują wskaźniki. Oznacza to,
				przechowywanie wartości jako pole jakiejś obwoluty {\ang wrapper}, a dostęp do niego poprzez operator dostępu do pola $\rightarrow$. Jednakże,
				problemem tego rozwiązania jest przeniesienie odpowiedzialności za zaimplementowanie wszystkich operatorów, konstruktorów, czy destruktorów
				na klasę otaczającą, oraz poprawne ich przekazanie do klasy wewnątrz. Przy tym podejściu ryzyko popełnienia gafy jest bardzo wysokie, dlatego też
				pojawiła się kolejna koncepcja.\n

				Polega ona na zaciągnięciu do pracy wcześniej wspomnianego wzorca {\it CRTP}, oraz publiczne dziedziczenie po każdym polu, co sprawiłoby, że
				do interfejs zostaje identyczny, dla dowolnej klasy, a jedyne co pozostaje do zaimplementowania, to poprawne przekierowanie konstruktorów
				i destruktorów.\n

				Jednakże, C++ jest językiem, gdzie istnieje rozróżnienie na typy złożone i~proste, po których nie można dziedziczyć. Aby pokryć ten przypadek,
				można skorzystać z rozbudowanego modułu do metaprogramowania w języku C++ i napisać dwie specjalizacje. Jedną dla typów prostych, który
				w dużym stopniu korzysta z~opisanego wcześniej rozwiązania, gdzie ilość rzeczy do przekierowania, nie jest tak duża. Drugą zaś,
				dla typów złożonych, gdzie można wykorzystać wcześniej wspomniany wzorzec {\it CRTP} i dziedziczyć po typach złożonych, takich jak klasa, czy struktura.\n

				Dzięki skorzystaniu z struktury {\it std::is\_fundamental\_v<T>}\cite{std_is_fundamental}, za pomocą której jest możliwe wyciągnięcie informacji,
				czy typ jest prosty, czy nie. Dodatkowo, dzięki wprowadzeniu operatora potrójnego porównania\cite{starship_operator} w~standardzie C++20, możliwym było
				przyspieszenie procedury przekierowywania operatorów poprzez przeciążenie wyłącznie jednego. Dodatkowo dodanie cichych konwersji dodatkowo redukuje
				dyskomfort w korzystaniu z fasady.\n

				Implementacja tego typu ma jeszcze jedną bardzo ważną zaletę: jest fasadą idealną, która może zostać przekazana jako referencja
				do klasy, którą opakowuje.
			}

			{
				\subsubsection{Problem przechowywania referencji}

				Poprzednie rozwiązanie w przypadku typów prostych umożliwia bardzo proste dodanie dodatkowego pola z referencją. Jednakże rozwiązanie to:
				po pierwsze przywołuje problem z puchnięciem klasy z każdym dodatkowym polem, a~po drugie mocno komplikuje rozwiązanie z dziedziczeniem po
				typach złożonych, gdzie naruszenie bazowego interfejsu poprzez dołożenie nowej zmiennej, czy metody naruszałoby wrażenie przeźroczystości
				biblioteki.

				Celem zaproponowania rozwiązania, należy wskazać czym statyczna referencja na pole klasy jest. Otóż jest to po przesunięcie względem
				adresu struktury danych. Wynika więc z tej definicji, że jest to adres możliwy do określenia, jeszcze podczas kompilacji,
				a to zaś implikuje możliwość przekazania go jako argument szablonu. Co jak się okazuje jest możliwe. Dzięki czemu, został rozwiązany problem
				przechowywania adresu do poprzedniego pola klasy, jest on po prostu przechowywany jako liczba (przesunięcie) z typem poprzedniego pola w klasie.

				Teraz, żeby dostać się do pola potrzebny jest wskaźnik na obiekt ({\it this}), a~następnie dodanie do niego posiadanego przesunięcia.
				Dodatkowo rozwiązany zostaje tutaj jeszcze jeden problem, a mianowicie problem z dostępem do nazwy pól.
			}

			{
				\subsubsection{Problem dostępu do nazwy pola}

				Celem pokazania, w jaki sposób następuje dostęp do nazwy pola i jednocześnie podsumowania aktualnej architektury, poniżej zostaje zamieszczony
				przykład zapisu na podstawie poprzednich kilku akapitów:\n

				\begin{lstlisting}[frame=single]
struct test_struct
{
	first_field<int> field_0;
	field<&test_struct::field_0, float> field_1;
};
				\end{lstlisting}

				Jak można zauważyć, celem odwołania się do referencji na poprzednie pole, konieczne jest odwołanie się do jego nazwy. Nie pozostaje to bez
				konsekwencji, które można wykorzystać, a zostanie to zaprezentowane, poprzez zamieszczenie kodu, który ma na celu wydrukować na ekranie
				zdemanglowany typ pola {\it field\_1}, a także wyjście z tego prostego programu:\n

				\begin{lstlisting}[frame=single]
#include <serek/serek.hpp>

struct test_struct
{
	serek::ffield<int> field_0;
	serek::field<&test_struct::field_0, float> field_1;
};

int main()
{
	std::cout << serek::type_name<decltype(&test_struct::field_1)>() << std::endl;
}
/*
Konsola:
	serek::detail::field_impl<&test_struct::field_0, double> test_struct::
*/
				\end{lstlisting}

				Wydobycie nazwy pola może nastąpić z zdemanglowanej nazwy typu pola, którą bajecznie prosto uzyskać, ponieważ jest ona zawarta
				w szablonie.
			}

			{
				\subsubsection{Problem punktu startowego}

				Wcześniej wspomniane wybory umożliwiły rozwiązanie wielu problemów i wyzwań. Niestety zawarcie referencji do ostatniego pola
				struktury danych wewnątrz klasy okazało się nie możliwe, bez odbierania użytkownikowi biblioteki pewnych funkcjonalności.
				Przekazywanie za pomocą wzorca projektowego {\it CRTP} nie jest możliwe przy deklaracji klasy z wcześniej wspomnianych powodów.\n

				Rozwiązanie, które zostało ostatecznie wykorzystane, to tworzenie aliasu docelowej nazwy klasy zaraz pod definicją klasy,
				zawierając w niej statyczną referencję do ostatniego pola klasy. Takie rozwiązanie daje maksimum elastyczności użytkownikowi,
				a także nie wprowadza żadnego zaburzenia w interfejs tworzonej klasy.\n

				Sam alias również nie jest do końca taki prosty, ponieważ korzysta z podobnej sztuczki co klasa odpowiedzialna, za przechowywanie
				kolejnych pól w klasie. Precyzując: dziedziczy po klasie, do której należy ostatnie pole klasy, dzięki czemu całość zostaje
				zapakowane w fasadę idealnie przeźroczystą z wygodnym dostępem do każdego pola w klasie. Poniżej zaktualizowany, przykład deklaracji klasy.\n

				\begin{lstlisting}[frame=single]
#include <serek/serek.hpp>

struct test_struct_impl
{
	serek::ffield<int> field_0;
	serek::field<&test_struct_impl::field_0, float> field_1;
	serek::field<&test_struct_impl::field_1, double> field_2;
};
using test_struct = serek::pack<&test_struct_impl::field_2>;
				\end{lstlisting}
			}

			{
				\subsubsection{Problem prostej podmiany sposobu obsługi typu}

				Jest to ostatni z naczelnych problemów, wymienionych na przestrzeni poprzednich akapitów. Rozwiązanie tego problemu,
				wymagało przemyślenia, lokalizacji kodu od serializacji i deserializacji, oraz sposobu na przemieszczanie się po takiej
				statycznej jednokierunkowej liście pól w klasie.\n

				Umieszczenie kodu od obsługi konkretnych typów, wydaje się najprościej umieścić w specjalizacjach dla konkretnych typów.
				Ma to kilka nieporządnych konsekwencji. Pierwszą jest taka, że wymagałoby to tworzenia częściowych specjalizacji, co
				wymuszałoby umieszczanie takiego kodu w całości w plikach nagłówkowych. Zdecydowanie wydłużałoby to czas kompilacji
				i~sprawiałoby, że sporo kodu, który powinien się znaleźć w plikach źródłowych, lądowałby w nagłówkach. Dodatkowo
				usztywniłoby to całą bibliotekę, ponieważ kod byłby za daleko od użytkownika, a jego nadpisanie poprzez na przykład
				przeciążenie funkcji dla danego typu czasochłonne, ponieważ musiałby się wdrażać w skomplikowaną implementację klas
				przechowujące pola, czy klasy.\n

				Dlatego koniecznością stało się wydzielenie kodu od serializacji do osobnej klasy. Szczęśliwie, istnieje wzorzec projektowy,
				który bardzo dobrze sprawdza się w przypadku konieczności wydzielenia funkcjonalności poza klasę - wizytator\cite{visitor_description}.
				Użycie go w przypadku tej implementacji jest bardzo proste i intuicyjne. Biblioteka zapewnia klasę bazową, po której dziedzicząc
				użytkownik tworzy własnego wizytatora w którym definiuje obsługę swoich typów, jako przeciążenia operatora wywołania ({\it operator()}),
				natomiast, wszystkie pozostałe przekierowuje do klasy bazowe, która ma zaimplementowane obsługę typów fundamentalnych.\n

				\begin{lstlisting}[frame=single]
struct hash_json_serializer : public serek::deserial::json::json_visitor_deserializer
{
	serek::visitor_result_t operator()(hash_t& any)
	{
		any = hash_t::from_string(this->get_top_token());
		return true;
	}
};
				\end{lstlisting}

				Powyższy przykład jest już gotowym do użycia wizytatorem na dowolnym obiekcie poddanym refleksji, przez niniejszą
				bibliotekę. Można go użyć za pomocą dostarczonej funkcji {\it serek::visit}, gdzie pierwszym parametrem jest obiekt, na którym
				chcemy dokonać operacji serializacji lub deserializacji, natomiast drugim parametrem jest wizytator.
			}
		}
	}

	{
		\section{Testy wydajnościowe}

		{
			\subsection{Środowisko testowe}

			{
				\subsubsection{Dobór technologii}
			}

			{
				\subsubsection{Konfiguracja}
			}
		}

		{
			\subsection{Wyniki}

			{
				\subsubsection{Surowe dane}
			}

			{
				\subsubsection{Analiza}
			}
		}

		{
			\subsection{Wnioski}
		}
	}

	\newpage

	{
		\begin{figure}[H]
			\centering
			\includegraphics[width=15cm,keepaspectratio=true]{./charts/output_with_charts_as_images/throughput_per_library.png}
			\caption{Wykres przepustowości cząstkowej, dla \Delta t  = 1s}
			\medskip
		\end{figure}
	}

	{
		\begin{figure}[H]
			\centering
			\includegraphics[width=15cm,keepaspectratio=true]{./charts/pre_generated_charts/throughput_summary_per_library_summary.png}
			\caption{Zestawienie zagregowanych charakterystyk opisujących przepustowość, dla różnych bibliotek}
			\medskip
		\end{figure}
	}

	{
		\begin{figure}[H]
			\centering
			\includegraphics[width=15cm,keepaspectratio=true]{./charts/pre_generated_charts/total_request_time_per_library_summary.png}
			\caption{Zestawienie zagregowanych charakterystyk opisujących całkowity czas wykonania zapytania, dla różnych bibliotek}
			\medskip
		\end{figure}
	}

	% \subsection{Pod Wstęp}
	% \subsubsection{Pod Pod Wstęp}

	% \begin{enumerate}
	% 	\item One
	% 	\item Two
	% 	\item Three
	% 	\begin{enumerate}
	% 		\item Three point one
	% 		\begin{enumerate}
	% 		\item Three point one, point one
	% 			\begin{enumerate}
	% 			\item Three point one, point one, point one 1234567890
	% 			\item Three point one, point one, point two
	% 			\end{enumerate}
	% 		\end{enumerate}
	% 	\end{enumerate}
	% 	\item Four
	% 	\item Five
	% 	\end{enumerate}

	% bibliography
	{
		\newpage
		\section{Bibliografia}
		\printbibliography[heading=none]
	}

	% list of tables
	{
		\newpage
		\section{Spis Tabel}
		\listoftables
		\thispagestyle{fancy}
		\newpage
	}

	% list of figures
	{
		\newpage
		\section{Spis Wykresów}
		\listoffigures
		\thispagestyle{fancy}
		\newpage
	}

\end{document}
